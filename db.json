{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/images/image-20200705080719531.png","path":"images/image-20200705080719531.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705080911284.png","path":"images/image-20200705080911284.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705081913538.png","path":"images/image-20200705081913538.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705081813409.png","path":"images/image-20200705081813409.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705082255746.png","path":"images/image-20200705082255746.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705084038680.png","path":"images/image-20200705084038680.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705082601441.png","path":"images/image-20200705082601441.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705090328171.png","path":"images/image-20200705090328171.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705090237078.png","path":"images/image-20200705090237078.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705094149223.png","path":"images/image-20200705094149223.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705103636003.png","path":"images/image-20200705103636003.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705103516138.png","path":"images/image-20200705103516138.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705105151258.png","path":"images/image-20200705105151258.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705105810107.png","path":"images/image-20200705105810107.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705111640511.png","path":"images/image-20200705111640511.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705111843003.png","path":"images/image-20200705111843003.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705112036630.png","path":"images/image-20200705112036630.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705112416101.png","path":"images/image-20200705112416101.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705112601211.png","path":"images/image-20200705112601211.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705155551919.png","path":"images/image-20200705155551919.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705155728557.png","path":"images/image-20200705155728557.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705161007423.png","path":"images/image-20200705161007423.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705161849557.png","path":"images/image-20200705161849557.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705161409533.png","path":"images/image-20200705161409533.png","modified":0,"renderable":0},{"_id":"source/images/image-20200705161812542.png","path":"images/image-20200705161812542.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706195127740.png","path":"images/image-20200706195127740.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706203419496.png","path":"images/image-20200706203419496.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706200739392.png","path":"images/image-20200706200739392.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706201904057.png","path":"images/image-20200706201904057.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706203835403.png","path":"images/image-20200706203835403.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706205821919.png","path":"images/image-20200706205821919.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706205947535.png","path":"images/image-20200706205947535.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706205756045.png","path":"images/image-20200706205756045.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706210000461.png","path":"images/image-20200706210000461.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707075847954.png","path":"images/image-20200707075847954.png","modified":0,"renderable":0},{"_id":"source/images/image-20200706211652779.png","path":"images/image-20200706211652779.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707080154039.png","path":"images/image-20200707080154039.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707084208115.png","path":"images/image-20200707084208115.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707084714886.png","path":"images/image-20200707084714886.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707085232646.png","path":"images/image-20200707085232646.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707095606813.png","path":"images/image-20200707095606813.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707091058346.png","path":"images/image-20200707091058346.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707101511025.png","path":"images/image-20200707101511025.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707085737207.png","path":"images/image-20200707085737207.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707101543871.png","path":"images/image-20200707101543871.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707103547712.png","path":"images/image-20200707103547712.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707203038615.png","path":"images/image-20200707203038615.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707203441718.png","path":"images/image-20200707203441718.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707104253530.png","path":"images/image-20200707104253530.png","modified":0,"renderable":0},{"_id":"source/images/image-20200707205634266.png","path":"images/image-20200707205634266.png","modified":0,"renderable":0},{"_id":"source/images/垃圾回收.gif","path":"images/垃圾回收.gif","modified":0,"renderable":0},{"_id":"source/PPT/1.png","path":"PPT/1.png","modified":0,"renderable":0},{"_id":"source/PPT/10.png","path":"PPT/10.png","modified":0,"renderable":0},{"_id":"source/PPT/11.png","path":"PPT/11.png","modified":0,"renderable":0},{"_id":"source/PPT/15.png","path":"PPT/15.png","modified":0,"renderable":0},{"_id":"source/PPT/13.png","path":"PPT/13.png","modified":0,"renderable":0},{"_id":"source/PPT/14.png","path":"PPT/14.png","modified":0,"renderable":0},{"_id":"source/PPT/20.png","path":"PPT/20.png","modified":0,"renderable":0},{"_id":"source/PPT/18.png","path":"PPT/18.png","modified":0,"renderable":0},{"_id":"source/PPT/2.png","path":"PPT/2.png","modified":0,"renderable":0},{"_id":"source/PPT/21.png","path":"PPT/21.png","modified":0,"renderable":0},{"_id":"source/PPT/22.png","path":"PPT/22.png","modified":0,"renderable":0},{"_id":"source/PPT/23.png","path":"PPT/23.png","modified":0,"renderable":0},{"_id":"source/PPT/25.png","path":"PPT/25.png","modified":0,"renderable":0},{"_id":"source/PPT/24.png","path":"PPT/24.png","modified":0,"renderable":0},{"_id":"source/PPT/27.png","path":"PPT/27.png","modified":0,"renderable":0},{"_id":"source/PPT/29.png","path":"PPT/29.png","modified":0,"renderable":0},{"_id":"source/PPT/28.png","path":"PPT/28.png","modified":0,"renderable":0},{"_id":"source/PPT/26.png","path":"PPT/26.png","modified":0,"renderable":0},{"_id":"source/PPT/3.png","path":"PPT/3.png","modified":0,"renderable":0},{"_id":"source/PPT/30.png","path":"PPT/30.png","modified":0,"renderable":0},{"_id":"source/PPT/31.png","path":"PPT/31.png","modified":0,"renderable":0},{"_id":"source/PPT/33.png","path":"PPT/33.png","modified":0,"renderable":0},{"_id":"source/PPT/32.png","path":"PPT/32.png","modified":0,"renderable":0},{"_id":"source/PPT/35.png","path":"PPT/35.png","modified":0,"renderable":0},{"_id":"source/PPT/36.png","path":"PPT/36.png","modified":0,"renderable":0},{"_id":"source/PPT/34.png","path":"PPT/34.png","modified":0,"renderable":0},{"_id":"source/PPT/37.png","path":"PPT/37.png","modified":0,"renderable":0},{"_id":"source/PPT/38.png","path":"PPT/38.png","modified":0,"renderable":0},{"_id":"source/PPT/4.png","path":"PPT/4.png","modified":0,"renderable":0},{"_id":"source/PPT/41.png","path":"PPT/41.png","modified":0,"renderable":0},{"_id":"source/PPT/42.png","path":"PPT/42.png","modified":0,"renderable":0},{"_id":"source/PPT/44.png","path":"PPT/44.png","modified":0,"renderable":0},{"_id":"source/PPT/43.png","path":"PPT/43.png","modified":0,"renderable":0},{"_id":"source/PPT/45.png","path":"PPT/45.png","modified":0,"renderable":0},{"_id":"source/PPT/46.png","path":"PPT/46.png","modified":0,"renderable":0},{"_id":"source/PPT/49.png","path":"PPT/49.png","modified":0,"renderable":0},{"_id":"source/PPT/5.png","path":"PPT/5.png","modified":0,"renderable":0},{"_id":"source/PPT/48.png","path":"PPT/48.png","modified":0,"renderable":0},{"_id":"source/PPT/51.png","path":"PPT/51.png","modified":0,"renderable":0},{"_id":"source/PPT/52.png","path":"PPT/52.png","modified":0,"renderable":0},{"_id":"source/PPT/53.png","path":"PPT/53.png","modified":0,"renderable":0},{"_id":"source/PPT/54.png","path":"PPT/54.png","modified":0,"renderable":0},{"_id":"source/PPT/50.png","path":"PPT/50.png","modified":0,"renderable":0},{"_id":"source/PPT/55.png","path":"PPT/55.png","modified":0,"renderable":0},{"_id":"source/PPT/57.png","path":"PPT/57.png","modified":0,"renderable":0},{"_id":"source/PPT/58.png","path":"PPT/58.png","modified":0,"renderable":0},{"_id":"source/PPT/59.png","path":"PPT/59.png","modified":0,"renderable":0},{"_id":"source/PPT/60.png","path":"PPT/60.png","modified":0,"renderable":0},{"_id":"source/PPT/64.png","path":"PPT/64.png","modified":0,"renderable":0},{"_id":"source/PPT/61.png","path":"PPT/61.png","modified":0,"renderable":0},{"_id":"source/PPT/62.png","path":"PPT/62.png","modified":0,"renderable":0},{"_id":"source/PPT/6.png","path":"PPT/6.png","modified":0,"renderable":0},{"_id":"source/PPT/63.png","path":"PPT/63.png","modified":0,"renderable":0},{"_id":"source/PPT/66.png","path":"PPT/66.png","modified":0,"renderable":0},{"_id":"source/PPT/65.png","path":"PPT/65.png","modified":0,"renderable":0},{"_id":"source/PPT/69.png","path":"PPT/69.png","modified":0,"renderable":0},{"_id":"source/PPT/70.png","path":"PPT/70.png","modified":0,"renderable":0},{"_id":"source/PPT/7.png","path":"PPT/7.png","modified":0,"renderable":0},{"_id":"source/PPT/73.png","path":"PPT/73.png","modified":0,"renderable":0},{"_id":"source/PPT/71.png","path":"PPT/71.png","modified":0,"renderable":0},{"_id":"source/PPT/75.png","path":"PPT/75.png","modified":0,"renderable":0},{"_id":"source/PPT/67.png","path":"PPT/67.png","modified":0,"renderable":0},{"_id":"source/PPT/76.png","path":"PPT/76.png","modified":0,"renderable":0},{"_id":"source/PPT/77.png","path":"PPT/77.png","modified":0,"renderable":0},{"_id":"source/PPT/72.png","path":"PPT/72.png","modified":0,"renderable":0},{"_id":"source/PPT/9.png","path":"PPT/9.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"ce3a0beee62a407fb214ce99b39f7619a011d83a","modified":1701590840790},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"49f681a203eecfa7127ac22edc13bd3b49693d0a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"cdde6c6d6a1bdf9fb965313e21d92cf6213582b6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"ad4ae0509e3c13073bf17bff0e8eec0a5da718ad","modified":1701590949319},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"b2f61b91fffb17d11ad56811f07d52d23f012741","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":499162500000},{"_id":"source/about/index.md","hash":"48a2a05213e0486198dc8b976793ba65a963438f","modified":1701593847436},{"_id":"public/local-search.xml","hash":"a5474e8f40d1486c7c1dcd1620d1b791d527402d","modified":1701595730897},{"_id":"public/about/index.html","hash":"83d0bc2a24a85e5392a4a020d93ea4cd91e10bd1","modified":1701595730897},{"_id":"public/archives/index.html","hash":"db8711798953aebe580d9ed894fe3708057e8d6f","modified":1701595730897},{"_id":"public/index.html","hash":"d79651e3f5df3089a17d2e8eba2efa15be8ed3cf","modified":1701595730897},{"_id":"public/archives/2023/index.html","hash":"9b72f84b56ddc622e348cb22e99f7e23fa191cca","modified":1701595730897},{"_id":"public/404.html","hash":"26a080ae89a9b47930727a65cc9c3b3dbbff7cb3","modified":1701595730897},{"_id":"public/archives/2023/12/index.html","hash":"b90aa509a0b5e9575950abd8a17ba7a03d133e3d","modified":1701595730897},{"_id":"public/tags/index.html","hash":"e1936f1b32f219b7cd57fa9d5e7638347377f454","modified":1701595730897},{"_id":"public/categories/index.html","hash":"5633e55b446a69b63eeffd51508c8e9fe267a026","modified":1701595730897},{"_id":"public/links/index.html","hash":"fa6f97d6a98f1b7b13d6f35bf57835fe1828d018","modified":1701595730897},{"_id":"public/2023/12/03/hello-world/index.html","hash":"92f5884a9b83dc72294fcd6d0b08d841b9864bfc","modified":1701595730897},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1701595730897},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1701595730897},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1701595730897},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1701595730897},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1701595730897},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1701595730897},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1701595730897},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1701595730897},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1701595730897},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1701595730897},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1701595730897},{"_id":"public/css/style.css","hash":"4b65ba99401dce8b954f99a41762967e21eb40c7","modified":1701595730897},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1701595730897},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1701595730897},{"_id":"public/css/main.css","hash":"526a4522eb54bb51772f51fb98295dc4fe03429f","modified":1701595730897},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1701595730897},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1701595730897},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1701595730897},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1701595730897},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1701595730897},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1701595730897},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1701595730897},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1701595730897},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1701595730897},{"_id":"source/_posts/类加载子系统.md","hash":"cde11c5473a47698913a2a2764ed543d71baa30c","modified":1701608243220},{"_id":"source/_posts/images/image-20200705090237078.png","hash":"20849cfdec9178a72ff147a3ee9ca3b116c9111b","modified":1701607023319},{"_id":"source/jvm/images/image-20200705090237078.png","hash":"20849cfdec9178a72ff147a3ee9ca3b116c9111b","modified":1701607023319},{"_id":"source/_posts/images/image-20200705081913538.png","hash":"853d8d274c5a127b16415017fb6882af54c58c3a","modified":1701607023319},{"_id":"source/_posts/images/image-20200705081813409.png","hash":"292b4f1d4ff7b99adacb0842932a6dc95f417cab","modified":1701607023319},{"_id":"source/_posts/images/image-20200705082255746.png","hash":"be4e911d134a19140a905c42669386febbb9867e","modified":1701607023319},{"_id":"source/_posts/images/image-20200705090328171.png","hash":"4b16f40b094dce8c10873fd4b527962217699431","modified":1701607023319},{"_id":"source/_posts/images/image-20200705094149223.png","hash":"7ed293684c015dfd06dc88b2d74810a2d16c5baa","modified":1701607023319},{"_id":"source/jvm/images/image-20200705081813409.png","hash":"292b4f1d4ff7b99adacb0842932a6dc95f417cab","modified":1701607023319},{"_id":"source/jvm/images/image-20200705081913538.png","hash":"853d8d274c5a127b16415017fb6882af54c58c3a","modified":1701607023319},{"_id":"source/jvm/images/image-20200705082255746.png","hash":"be4e911d134a19140a905c42669386febbb9867e","modified":1701607023319},{"_id":"source/jvm/images/image-20200705090328171.png","hash":"4b16f40b094dce8c10873fd4b527962217699431","modified":1701607023319},{"_id":"source/jvm/images/image-20200705094149223.png","hash":"7ed293684c015dfd06dc88b2d74810a2d16c5baa","modified":1701607023319},{"_id":"source/_posts/images/image-20200705080719531.png","hash":"c60f44f584a5d02aae45dc0bdef7932a06e78002","modified":1701607023319},{"_id":"source/_posts/images/image-20200705082601441.png","hash":"e5bff9fd77e96e926209dec82d6cefdb8a7d28ca","modified":1701607023319},{"_id":"source/_posts/images/image-20200705084038680.png","hash":"0dfd39d72d75521c7b19d1a2ea44aa55873ff375","modified":1701607023319},{"_id":"source/_posts/images/image-20200705103516138.png","hash":"05934b5536d201bf14cf593948a1db02a0d35b79","modified":1701607023319},{"_id":"source/jvm/images/image-20200705080719531.png","hash":"c60f44f584a5d02aae45dc0bdef7932a06e78002","modified":1701607023319},{"_id":"source/jvm/images/image-20200705082601441.png","hash":"e5bff9fd77e96e926209dec82d6cefdb8a7d28ca","modified":1701607023319},{"_id":"source/jvm/images/image-20200705084038680.png","hash":"0dfd39d72d75521c7b19d1a2ea44aa55873ff375","modified":1701607023319},{"_id":"source/jvm/images/image-20200705103516138.png","hash":"05934b5536d201bf14cf593948a1db02a0d35b79","modified":1701607023319},{"_id":"source/_posts/images/image-20200705080911284.png","hash":"7a38e064b14f803a69eb1a3b59d26bc5170903a9","modified":1701607023319},{"_id":"source/_posts/images/image-20200705105151258.png","hash":"68e1cb4066f7a2f62f4f1b3ef036e68e1a0f2d1e","modified":1701607023319},{"_id":"source/_posts/images/image-20200705103636003.png","hash":"934951c09fb9c4eebc16d8a2258592920bb0ea26","modified":1701607023319},{"_id":"source/jvm/images/image-20200705080911284.png","hash":"7a38e064b14f803a69eb1a3b59d26bc5170903a9","modified":1701607023319},{"_id":"source/jvm/images/image-20200705103636003.png","hash":"934951c09fb9c4eebc16d8a2258592920bb0ea26","modified":1701607023319},{"_id":"source/jvm/images/image-20200705105151258.png","hash":"68e1cb4066f7a2f62f4f1b3ef036e68e1a0f2d1e","modified":1701607023319},{"_id":"source/_posts/images/image-20200705105810107.png","hash":"c51c0c76538db07558cf3cba481cb2e1780bc0f9","modified":1701607023319},{"_id":"source/jvm/images/image-20200705105810107.png","hash":"c51c0c76538db07558cf3cba481cb2e1780bc0f9","modified":1701607023319},{"_id":"source/images/image-20200705090237078.png","hash":"20849cfdec9178a72ff147a3ee9ca3b116c9111b","modified":1701607023319},{"_id":"source/images/image-20200705081913538.png","hash":"853d8d274c5a127b16415017fb6882af54c58c3a","modified":1701607023319},{"_id":"source/images/image-20200705082255746.png","hash":"be4e911d134a19140a905c42669386febbb9867e","modified":1701607023319},{"_id":"source/images/image-20200705081813409.png","hash":"292b4f1d4ff7b99adacb0842932a6dc95f417cab","modified":1701607023319},{"_id":"source/images/image-20200705090328171.png","hash":"4b16f40b094dce8c10873fd4b527962217699431","modified":1701607023319},{"_id":"source/images/image-20200705094149223.png","hash":"7ed293684c015dfd06dc88b2d74810a2d16c5baa","modified":1701607023319},{"_id":"source/images/image-20200705080719531.png","hash":"c60f44f584a5d02aae45dc0bdef7932a06e78002","modified":1701607023319},{"_id":"source/images/image-20200705084038680.png","hash":"0dfd39d72d75521c7b19d1a2ea44aa55873ff375","modified":1701607023319},{"_id":"source/images/image-20200705082601441.png","hash":"e5bff9fd77e96e926209dec82d6cefdb8a7d28ca","modified":1701607023319},{"_id":"source/images/image-20200705103516138.png","hash":"05934b5536d201bf14cf593948a1db02a0d35b79","modified":1701607023319},{"_id":"source/images/image-20200705080911284.png","hash":"7a38e064b14f803a69eb1a3b59d26bc5170903a9","modified":1701607023319},{"_id":"source/images/image-20200705103636003.png","hash":"934951c09fb9c4eebc16d8a2258592920bb0ea26","modified":1701607023319},{"_id":"source/images/image-20200705105151258.png","hash":"68e1cb4066f7a2f62f4f1b3ef036e68e1a0f2d1e","modified":1701607023319},{"_id":"source/images/image-20200705105810107.png","hash":"c51c0c76538db07558cf3cba481cb2e1780bc0f9","modified":1701607023319},{"_id":"source/_posts/JVM-运行时数据区概述及线程.md","hash":"6a713c71496f6e7b1c3830d45abfaa23f6ab5c76","modified":1701608675039},{"_id":"source/images/image-20200705111843003.png","hash":"184e1ee7ec59e3f0de734b46370ead8a61140363","modified":1701607023335},{"_id":"source/images/image-20200705112601211.png","hash":"b658e72306a5f328994104ceed364ba4eca10189","modified":1701607023335},{"_id":"source/images/image-20200705111640511.png","hash":"87f90a65b36a95cf2fd01cfd6756b7452ed22784","modified":1701607023335},{"_id":"source/images/image-20200705112036630.png","hash":"4484f62c9f5ebeca29ac5b274e70396ef4d1e37f","modified":1701607023335},{"_id":"source/images/image-20200705112416101.png","hash":"2bbc650222dce101dc39fa3ed5cbbb3b15ef6aa5","modified":1701607023335},{"_id":"source/_posts/程序计数器.md","hash":"a8adb931ffa85ed45cd97afd8cc0f6c67cd0eb18","modified":1701609033556},{"_id":"source/images/image-20200705161409533.png","hash":"d079319ebb743ae71f02605eed87da9ecbc197b1","modified":1701607023335},{"_id":"source/images/image-20200705161812542.png","hash":"76a9ca0847a75d53b069da0a3821ad9ac2f49f84","modified":1701607023335},{"_id":"source/images/image-20200705161849557.png","hash":"7ab6fbf102e1a507b8555492de0cd63528b4f042","modified":1701607023335},{"_id":"source/images/image-20200705155551919.png","hash":"def48f33b3d5bfa91caeadf8ff3e1c4bc0a3ec1b","modified":1701607023335},{"_id":"source/images/image-20200705155728557.png","hash":"5b0419debf47f35e78ba2b1252f556a61866450a","modified":1701607023335},{"_id":"source/images/image-20200705161007423.png","hash":"880ef9a3eb8a156af91d9c46bb8dbaf4d1ad5a89","modified":1701607023335},{"_id":"source/PPT/1.png","hash":"c10e0bd9b5acfee3b98fc08009da45fc85cab57b","modified":1701607023366},{"_id":"source/PPT/14.png","hash":"a98dba904ee368e03fa672b63e1ec6029e112ddc","modified":1701607023366},{"_id":"source/PPT/20.png","hash":"2ecde51b494c5a68615cf32481b24235b837a8a8","modified":1701607023366},{"_id":"source/PPT/25.png","hash":"ab8017c589bfa3d507b30b4098681c718ff2f7d1","modified":1701607023382},{"_id":"source/PPT/28.png","hash":"13f70f048b203584d25d2e792f22c3dcc416b25d","modified":1701607023382},{"_id":"source/PPT/41.png","hash":"355f718b54b5fe70767cd96c02d1ae6d29fc6d56","modified":1701607023397},{"_id":"source/PPT/44.png","hash":"798fc8ac7c32c66c2fcaa0a471f370013ccd3a8f","modified":1701607023397},{"_id":"source/_posts/java堆.md","hash":"0c3f9a206c2c084f19c9738331307e56f2f9488d","modified":1701609287204},{"_id":"source/images/image-20200706205756045.png","hash":"2e309294e64a8a0b9b70dadd51457b4939f0f037","modified":1701607023460},{"_id":"source/PPT/24.png","hash":"afb7f648eb33621cbff7792f9adc058a86155763","modified":1701607023382},{"_id":"source/PPT/27.png","hash":"c23bfe0e5595b360718bf9ed5c44991b90ce7afc","modified":1701607023382},{"_id":"source/PPT/29.png","hash":"7770a28404668859f480b3cd221ba52cae6736ba","modified":1701607023382},{"_id":"source/PPT/33.png","hash":"f169871fa54962d53f7f220afaa4c3d40c1fc518","modified":1701607023382},{"_id":"source/PPT/32.png","hash":"d5788f98084440eafbf5fb74af6bedfe50fc69f8","modified":1701607023382},{"_id":"source/PPT/4.png","hash":"757aeb4becfdf5c39a74ebbb95a7f9e628842161","modified":1701607023397},{"_id":"source/PPT/48.png","hash":"68424b32f8352df88abe5b7e7be50c2cedcb2c51","modified":1701607023413},{"_id":"source/PPT/51.png","hash":"7d2ad29e58f2f6ad5d04bc49afa0dcca20f82dd8","modified":1701607023413},{"_id":"source/PPT/54.png","hash":"fa5c8cc6d6502b750bff814eb4d5bcf03a705c7a","modified":1701607023413},{"_id":"source/PPT/58.png","hash":"f8ad254209307583b0f6101bd57c0afe6ea8a5c4","modified":1701607023413},{"_id":"source/PPT/61.png","hash":"f2c2e6baf44d1b936e532520994561bcd3c5e66b","modified":1701607023429},{"_id":"source/PPT/65.png","hash":"63d99b339b91c58e98c8983c71dd132f96b027eb","modified":1701607023429},{"_id":"source/PPT/73.png","hash":"899eb26bb57d6f505dbe16dae29fd75a1536f9ab","modified":1701607023444},{"_id":"source/PPT/9.png","hash":"115d8de913470669b5cce64802708141b71de725","modified":1701607023460},{"_id":"source/images/image-20200706201904057.png","hash":"10bf7dd7cb4713ba9d263299d761728a705bbb23","modified":1701607023460},{"_id":"source/images/image-20200706210000461.png","hash":"fe741001f868ddc6a184c56a209d17915bff17bb","modified":1701607023460},{"_id":"source/images/image-20200707075847954.png","hash":"625a66b8d5c37f5b47bc41eb5076aec2d1242fc0","modified":1701607023460},{"_id":"source/images/image-20200707080154039.png","hash":"4c73a20ac25a9a64b9c0b22990d841187b2b08c9","modified":1701607023476},{"_id":"source/images/image-20200707084208115.png","hash":"8aeb34d5145267919b584081bb264c4841095f9f","modified":1701607023476},{"_id":"source/images/image-20200707084714886.png","hash":"bac9c7a1d3a09a94fce66e53a83dbde20bd55907","modified":1701607023476},{"_id":"source/images/image-20200707101511025.png","hash":"54a67dbc1ec4998c437deb8598636bcd302990e6","modified":1701607023476},{"_id":"source/images/image-20200707101543871.png","hash":"9a10e95c95abbbff6768cde919446bcda28ad141","modified":1701607023476},{"_id":"source/images/image-20200707103547712.png","hash":"b9c2fea17dd4c765e544b933c98baf981c52e409","modified":1701607023476},{"_id":"source/images/image-20200707203038615.png","hash":"15fe98cae3c99be3883aa79da7126b5042b88293","modified":1701607023476},{"_id":"source/images/image-20200707203441718.png","hash":"1849c838359d821e31dd42b930951671827cd893","modified":1701607023476},{"_id":"source/PPT/11.png","hash":"8fc474537a3d4e1dbbab99b904d6ca5af651e3cb","modified":1701607023366},{"_id":"source/PPT/13.png","hash":"372423b66ad06a68a4f8339007705b6318be3c70","modified":1701607023366},{"_id":"source/PPT/22.png","hash":"8eb2190fdc0292587f38097ebf8d8f05923ea205","modified":1701607023382},{"_id":"source/PPT/23.png","hash":"5d781b5eba39b1f6d9845db3809796ec69a45448","modified":1701607023382},{"_id":"source/PPT/31.png","hash":"f06e71d818c54476fdcf6d84d6edd168f7392475","modified":1701607023382},{"_id":"source/PPT/30.png","hash":"691ccac7ebf6685cb3d4852475c219f2b14a7ed4","modified":1701607023382},{"_id":"source/PPT/49.png","hash":"319aecb7fce855d0d48db7e113ca3f3a8d868d21","modified":1701607023413},{"_id":"source/PPT/5.png","hash":"62c7750f1484c48b660241c3336856ce20fe9129","modified":1701607023413},{"_id":"source/PPT/53.png","hash":"1f4af02ce054368d47450bba272eb7a7d5b027bf","modified":1701607023413},{"_id":"source/PPT/6.png","hash":"5896eb64652ba7984b6b1f3964e0d1baa92e2d07","modified":1701607023429},{"_id":"source/PPT/64.png","hash":"b137f993560f84e93c0bebcb09a216d0220fbbc1","modified":1701607023429},{"_id":"source/images/image-20200706195127740.png","hash":"a2d3269196bded453181a325c091e15693a35117","modified":1701607023460},{"_id":"source/images/image-20200706203835403.png","hash":"df5fe65bec14aac174b049d8944601bf3b937b48","modified":1701607023460},{"_id":"source/images/image-20200706205947535.png","hash":"44f83d4ed76aa0e9bca176eb45730b1cc406485f","modified":1701607023460},{"_id":"source/images/image-20200706211652779.png","hash":"1a9a9a73735c39a87187c41880f073aac82e5a3f","modified":1701607023460},{"_id":"source/images/image-20200707085232646.png","hash":"beda02177470c7253444b11ef96d9eaa85fc17d7","modified":1701607023476},{"_id":"source/images/image-20200707104253530.png","hash":"02589807733dc68242cc20ab5b3ed9e30f56c09e","modified":1701607023476},{"_id":"source/images/垃圾回收.gif","hash":"5372d8ea294608d8e6766f38b71e0931ee88c955","modified":1701607023476},{"_id":"source/PPT/18.png","hash":"2ca7494dcb1ef9a1431c4a1b99d5d9b1a470f16f","modified":1701607023366},{"_id":"source/PPT/15.png","hash":"fdeff193177913668a4d98f1bfcbb75ba67fdd7b","modified":1701607023366},{"_id":"source/PPT/21.png","hash":"0d4728ccb90c5ea86f2f0e9d36d8168d9ec91b48","modified":1701607023382},{"_id":"source/PPT/35.png","hash":"4cda97749afa79b148d74111053c0cdae29a4c20","modified":1701607023397},{"_id":"source/PPT/37.png","hash":"fe9c85df2f5c58fbf68b81dfab84adb27e04bc41","modified":1701607023397},{"_id":"source/PPT/36.png","hash":"15024505e9cb7ed3f02a4d967dcff3ea885c8225","modified":1701607023397},{"_id":"source/PPT/42.png","hash":"674205cd6ee4c0f23e240979242692f5ec3fe42b","modified":1701607023397},{"_id":"source/PPT/43.png","hash":"e95663935be725bdca9e907852bde0744f860664","modified":1701607023397},{"_id":"source/PPT/45.png","hash":"fb3a65f354339e62f50104c9a1a45be3d0541202","modified":1701607023397},{"_id":"source/PPT/46.png","hash":"dc2c41a2e2e655f90ef09e54288ef28620efabeb","modified":1701607023413},{"_id":"source/PPT/50.png","hash":"ae70f279f6d22ff7bcf159c272c6f6cec893c555","modified":1701607023413},{"_id":"source/PPT/52.png","hash":"cea9d8b4840b9807454f89898c870f3a81c58ac4","modified":1701607023413},{"_id":"source/PPT/55.png","hash":"4c557c031ea8d4aae00c575e4ba8232b07e25032","modified":1701607023413},{"_id":"source/PPT/62.png","hash":"6537e823e33cf223d8ea44d8c149591525d1efa9","modified":1701607023429},{"_id":"source/PPT/67.png","hash":"9200a98fbfdafa4072cc8a123d6acf0e804c6433","modified":1701607023429},{"_id":"source/PPT/69.png","hash":"34a7aa6db5f77c7aa7245a93ba304c3631cf574a","modified":1701607023444},{"_id":"source/PPT/7.png","hash":"b59e8c300587692a32b1c2a398df0a43a720a16f","modified":1701607023444},{"_id":"source/PPT/70.png","hash":"a55fd6580b891b2e6ce20bbdb4390f3019789c4e","modified":1701607023444},{"_id":"source/PPT/72.png","hash":"b222f0110433e0656f67db884fc0c80d57e92781","modified":1701607023444},{"_id":"source/images/image-20200706203419496.png","hash":"1cbdcf6d93b48f6489a926f70baabd6fad68ec4a","modified":1701607023460},{"_id":"source/images/image-20200707091058346.png","hash":"4bf1501b2db2559fe1e4764e43d6c5b817f3cdb1","modified":1701607023476},{"_id":"source/images/image-20200707095606813.png","hash":"2e74274cf71ddc390cc01f3ff049525636170bd3","modified":1701607023476},{"_id":"source/images/image-20200707085737207.png","hash":"abc1966132672107802205db4de93c72400428e1","modified":1701607023476},{"_id":"source/PPT/2.png","hash":"b9849b500a8e178bea2ab32a368dfc043e5a298a","modified":1701607023366},{"_id":"source/PPT/26.png","hash":"ebd15f4f7d89b036723c513252a4d5707b699b5e","modified":1701607023382},{"_id":"source/PPT/3.png","hash":"3810a07751fe443912436c72c72cf7e7c7db83e6","modified":1701607023382},{"_id":"source/PPT/38.png","hash":"d4b94032ba66595a534341ec776ddc35b984ade3","modified":1701607023397},{"_id":"source/PPT/60.png","hash":"dedc713f3e70cf6b273da66d53e3a0e8d8d7d9b0","modified":1701607023429},{"_id":"source/PPT/63.png","hash":"12e6628367aa9c66c83ee0bfd301e6c79d947823","modified":1701607023429},{"_id":"source/PPT/66.png","hash":"321bac1159d07efec67f45f6786ba952f7cb866b","modified":1701607023429},{"_id":"source/PPT/71.png","hash":"783b2cc506d7ba7fb8d9515528a018234bebaf4f","modified":1701607023444},{"_id":"source/PPT/77.png","hash":"130e0b8329c7c93c730407f3cfe2d3c9dd84f0e5","modified":1701607023460},{"_id":"source/PPT/10.png","hash":"da9184b126beb69471daabfe5efdeb015a207bc1","modified":1701607023366},{"_id":"source/PPT/34.png","hash":"45cb9da15fd4b525cc1c87c8b358a72eec5a1a95","modified":1701607023397},{"_id":"source/PPT/57.png","hash":"e86dfab053d75d0f3e4435cc7ba058f01a096802","modified":1701607023413},{"_id":"source/PPT/59.png","hash":"448004dd03e1dea652004684c46aef829d6bce75","modified":1701607023429},{"_id":"source/PPT/75.png","hash":"296afb9add115eeca66aee322c2939e9bfafac10","modified":1701607023444},{"_id":"source/images/image-20200707205634266.png","hash":"0b382d2e4b3f7c0e719ba974e9316f42d236e5da","modified":1701607023476},{"_id":"source/PPT/76.png","hash":"ae2db6c6aad0ee4e2298f46074fc288e63ed941d","modified":1701607023444},{"_id":"source/images/image-20200706205821919.png","hash":"a8f23a54f6255d2ff1e05e0fd7aaf685b742725a","modified":1701607023460},{"_id":"source/images/image-20200706200739392.png","hash":"89bc67ffc3e8b10dce4c7eddb0d95ccf16df4dab","modified":1701607023460}],"Category":[{"name":"java","_id":"clpphmypu0001ekwf8gqb444a"}],"Data":[],"Page":[{"title":"关于我","date":"2023-12-03T08:54:11.000Z","_content":"\n大家好，我是时长两年半的Java程序员，喜欢 C T R L, MUSIC~~~~ \n\nDUANG DUANG DUANG ~~~","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2023-12-03 16:54:11\n---\n\n大家好，我是时长两年半的Java程序员，喜欢 C T R L, MUSIC~~~~ \n\nDUANG DUANG DUANG ~~~","updated":"2023-12-03T08:57:27.436Z","path":"about/index.html","comments":1,"layout":"page","_id":"clpp924k90000jcwf6qg649cd","content":"<p>大家好，我是时长两年半的Java程序员，喜欢 C T R L, MUSIC~~~~ </p>\n<p>DUANG DUANG DUANG ~~~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大家好，我是时长两年半的Java程序员，喜欢 C T R L, MUSIC~~~~ </p>\n<p>DUANG DUANG DUANG ~~~</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-12-03T08:05:19.697Z","updated":"1985-10-26T08:15:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpp79txw0000p0wf5kkxfy4g","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"类加载子系统","date":"2023-12-03T12:53:58.000Z","_content":"\n\n# 类加载子系统\n\n## 概述\n\n![image-20200705080719531](images/image-20200705080719531.png)\n\n完整图如下\n\n![image-20200705080911284](images/image-20200705080911284.png)\n\n如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？\n\n- 类加载器\n- 执行引擎\n\n## 类加载器子系统作用\n\n类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。\n\nClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。\n\n加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）\n\n![image-20200705081813409](images/image-20200705081813409.png)\n\n- class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。\n- class file加载到JVM中，被称为DNA元数据模板，放在方法区。\n- 在.class文件->JVM->最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。\n\n![image-20200705081913538](images/image-20200705081913538.png)\n\n## 类的加载过程\n\n例如下面的一段简单的代码\n\n```java\n/**\n * 类加载子系统\n * @author: 陌溪\n * @create: 2020-07-05-8:24\n */\npublic class HelloLoader {\n    public static void main(String[] args) {\n        System.out.println(\"我已经被加载啦\");\n    }\n}\n```\n\n它的加载过程是怎么样的呢?\n\n![image-20200705082255746](images/image-20200705082255746.png)\n\n完整的流程图如下所示\n\n![image-20200705082601441](images/image-20200705082601441.png)\n\n### 加载阶段\n\n通过一个类的全限定名获取定义此类的二进制字节流\n\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n### 加载class文件的方式\n\n- 从本地系统中直接加载\n- 通过网络获取，典型场景：Web Applet\n- 从zip压缩包中读取，成为日后jar、war格式的基础\n- 运行时计算生成，使用最多的是：动态代理技术\n- 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见\n- 从加密文件中获取，典型的防Class文件被反编译的保护措施\n\n### 链接阶段\n\n#### 验证 Verify\n\n目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。\n\n主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。\n\n> 工具：Binary Viewer查看\n\n![image-20200705084038680](images/image-20200705084038680.png)\n\n如果出现不合法的字节码文件，那么将会验证不通过\n\n同时我们可以通过安装IDEA的插件，来查看我们的Class文件\n\n![image-20200705090237078](images/image-20200705090237078.png)\n\n安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了\n\n![image-20200705090328171](images/image-20200705090328171.png)\n\n### 准备 Prepare\n\n为类变量分配内存并且设置该类变量的默认初始值，即零值。\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-8:42\n */\npublic class HelloApp {\n    private static int a = 1;  // 准备阶段为0，在下个阶段，也就是初始化的时候才是1\n    public static void main(String[] args) {\n        System.out.println(a);\n    }\n}\n```\n\n上面的变量a在准备阶段会赋初始值，但不是1，而是0。\n\n这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；\n\n这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。\n\n例如下面这段代码\n\n### 解析 Resolve\n\n将常量池内的符号引用转换为直接引用的过程。\n\n事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等\n\n### 初始化阶段\n\n初始化阶段就是执行类构造器法<clinit>（）的过程。\n\n此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。\n\n- 也就是说，当我们代码中包含static变量的时候，就会有clinit方法\n\n构造器方法中指令按语句在源文件中出现的顺序执行。\n\n<clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。\n\n- 任何一个类在声明后，都有生成一个构造器，默认是空参构造器\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-8:47\n */\npublic class ClassInitTest {\n    private static int num = 1;\n    static {\n        num = 2;\n        number = 20;\n        System.out.println(num);\n        System.out.println(number);  //报错，非法的前向引用\n    }\n\n    private static int number = 10;\n\n    public static void main(String[] args) {\n        System.out.println(ClassInitTest.num); // 2\n        System.out.println(ClassInitTest.number); // 10\n    }\n}\n```\n\n关于涉及到父类时候的变量赋值过程\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:06\n */\npublic class ClinitTest1 {\n    static class Father {\n        public static int A = 1;\n        static {\n            A = 2;\n        }\n    }\n\n    static class Son extends Father {\n        public static int b = A;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Son.b);\n    }\n}\n```\n\n我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回\n\n```bash\niconst_1\nputstatic #2 <com/atguigu/java/chapter02/ClinitTest1$Father.A>\niconst_2\nputstatic #2 <com/atguigu/java/chapter02/ClinitTest1$Father.A>\nreturn\n```\n\n虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:14\n */\npublic class DeadThreadTest {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t 线程t1开始\");\n            new DeadThread();\n        }, \"t1\").start();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t 线程t2开始\");\n            new DeadThread();\n        }, \"t2\").start();\n    }\n}\nclass DeadThread {\n    static {\n        if (true) {\n            System.out.println(Thread.currentThread().getName() + \"\\t 初始化当前类\");\n            while(true) {\n\n            }\n        }\n    }\n}\n```\n\n上面的代码，输出结果为\n\n```\n线程t1开始\n线程t2开始\n线程t2 初始化当前类\n```\n\n从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程\n\n## 类加载器的分类\n\nJVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。\n\n从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。\n\n无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：\n\n![image-20200705094149223](images/image-20200705094149223.png)\n\n这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。\n\n我们通过一个类，获取它不同的加载器\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:47\n */\npublic class ClassLoaderTest {\n    public static void main(String[] args) {\n        // 获取系统类加载器\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n\n        // 获取其上层的：扩展类加载器\n        ClassLoader extClassLoader = systemClassLoader.getParent();\n        System.out.println(extClassLoader);\n\n        // 试图获取 根加载器\n        ClassLoader bootstrapClassLoader = extClassLoader.getParent();\n        System.out.println(bootstrapClassLoader);\n\n        // 获取自定义加载器\n        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\n        System.out.println(classLoader);\n        \n        // 获取String类型的加载器\n        ClassLoader classLoader1 = String.class.getClassLoader();\n        System.out.println(classLoader1);\n    }\n}\n```\n\n得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。\n\n```\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@1540e19d\nnull\nsun.misc.Launcher$AppClassLoader@18b4aac2\nnull \n```\n\n### 虚拟机自带的加载器\n\n#### 启动类加载器（引导类加载器，Bootstrap ClassLoader）\n\n- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。\n- 它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n- 并不继承自ava.lang.ClassLoader，没有父加载器。\n- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n### 扩展类加载器（Extension ClassLoader）\n\n- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。\n- 派生于ClassLoader类\n- 父类加载器为启动类加载器\n- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\n\n### 应用程序类加载器（系统类加载器，AppClassLoader）\n\n- javI语言编写，由sun.misc.LaunchersAppClassLoader实现\n- 派生于ClassLoader类\n- 父类加载器为扩展类加载器\n- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\n- 通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器\n\n### 用户自定义类加载器\n\n在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。\n为什么要自定义类加载器？\n\n- 隔离加载类\n- 修改类加载的方式\n- 扩展加载源\n- 防止源码泄漏\n\n用户自定义类加载器实现步骤：\n\n- 开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求\n- 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中\n- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n### 查看根加载器所能加载的目录\n\n刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-10:17\n */\npublic class ClassLoaderTest1 {\n    public static void main(String[] args) {\n        System.out.println(\"*********启动类加载器************\");\n        // 获取BootstrapClassLoader 能够加载的API的路径\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url.toExternalForm());\n        }\n\n        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器\n        ClassLoader classLoader = Provider.class.getClassLoader();\n    }\n}\n```\n\n得到的结果\n\n```\n*********启动类加载器************\nfile:/E:/Software/JDK1.8/Java/jre/lib/resources.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/rt.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/sunrsasign.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jsse.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jce.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/charsets.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jfr.jar\nfile:/E:/Software/JDK1.8/Java/jre/classes\nnull\n```\n\n### 关于ClassLoader\n\nClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）\n\n![image-20200705103516138](images/image-20200705103516138.png)\n\nsun.misc.Launcher 它是一个java虚拟机的入口应用\n\n![image-20200705103636003](images/image-20200705103636003.png)\n\n获取ClassLoader的途径\n\n- 获取当前ClassLoader：clazz.getClassLoader()\n- 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()\n- 获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n- 获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n\n## 双亲委派机制\n\nJava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\n\n### 工作原理\n\n- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n![image-20200705105151258](images/image-20200705105151258.png)\n\n### 双亲委派机制举例\n\n当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。\n\n![image-20200705105810107](images/image-20200705105810107.png)\n\n### 沙箱安全机制\n\n自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\n\n### 双亲委派机制的优势\n\n通过上面的例子，我们可以知道，双亲机制可以\n\n- 避免类的重复加载\n- 保护程序安全，防止核心API被随意篡改\n  - 自定义类：java.lang.String\n  - 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）\n\n## 其它\n\n###  如何判断两个class对象是否相同\n\n在JVM中表示两个class对象是否为同一个类存在两个必要条件：\n- 类的完整类名必须一致，包括包名。\n- 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。\n\n换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。\n\nJVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。\n\n### 类的主动使用和被动使用\n\nJava程序对类的使用方式分为：王动使用和被动使用。\n主动使用，又分为七种情况：\n\n- 创建类的实例\n- 访问某个类或接口的静态变量，或者对该静态变量赋值\n- 调用类的静态方法I\n- 反射（比如：Class.forName（\"com.atguigu.Test\"））\n- 初始化一个类的子类\n- Java虚拟机启动时被标明为启动类的类\n- JDK7开始提供的动态语言支持：\n- java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化\n\n除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。","source":"_posts/类加载子系统.md","raw":"---\ntitle: 类加载子系统\ndate: 2023-12-03 20:53:58\ntags: jvm\ncategories: java\n---\n\n\n# 类加载子系统\n\n## 概述\n\n![image-20200705080719531](images/image-20200705080719531.png)\n\n完整图如下\n\n![image-20200705080911284](images/image-20200705080911284.png)\n\n如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？\n\n- 类加载器\n- 执行引擎\n\n## 类加载器子系统作用\n\n类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。\n\nClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。\n\n加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）\n\n![image-20200705081813409](images/image-20200705081813409.png)\n\n- class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。\n- class file加载到JVM中，被称为DNA元数据模板，放在方法区。\n- 在.class文件->JVM->最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。\n\n![image-20200705081913538](images/image-20200705081913538.png)\n\n## 类的加载过程\n\n例如下面的一段简单的代码\n\n```java\n/**\n * 类加载子系统\n * @author: 陌溪\n * @create: 2020-07-05-8:24\n */\npublic class HelloLoader {\n    public static void main(String[] args) {\n        System.out.println(\"我已经被加载啦\");\n    }\n}\n```\n\n它的加载过程是怎么样的呢?\n\n![image-20200705082255746](images/image-20200705082255746.png)\n\n完整的流程图如下所示\n\n![image-20200705082601441](images/image-20200705082601441.png)\n\n### 加载阶段\n\n通过一个类的全限定名获取定义此类的二进制字节流\n\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n\n在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n### 加载class文件的方式\n\n- 从本地系统中直接加载\n- 通过网络获取，典型场景：Web Applet\n- 从zip压缩包中读取，成为日后jar、war格式的基础\n- 运行时计算生成，使用最多的是：动态代理技术\n- 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见\n- 从加密文件中获取，典型的防Class文件被反编译的保护措施\n\n### 链接阶段\n\n#### 验证 Verify\n\n目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。\n\n主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。\n\n> 工具：Binary Viewer查看\n\n![image-20200705084038680](images/image-20200705084038680.png)\n\n如果出现不合法的字节码文件，那么将会验证不通过\n\n同时我们可以通过安装IDEA的插件，来查看我们的Class文件\n\n![image-20200705090237078](images/image-20200705090237078.png)\n\n安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了\n\n![image-20200705090328171](images/image-20200705090328171.png)\n\n### 准备 Prepare\n\n为类变量分配内存并且设置该类变量的默认初始值，即零值。\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-8:42\n */\npublic class HelloApp {\n    private static int a = 1;  // 准备阶段为0，在下个阶段，也就是初始化的时候才是1\n    public static void main(String[] args) {\n        System.out.println(a);\n    }\n}\n```\n\n上面的变量a在准备阶段会赋初始值，但不是1，而是0。\n\n这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；\n\n这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。\n\n例如下面这段代码\n\n### 解析 Resolve\n\n将常量池内的符号引用转换为直接引用的过程。\n\n事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等\n\n### 初始化阶段\n\n初始化阶段就是执行类构造器法<clinit>（）的过程。\n\n此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。\n\n- 也就是说，当我们代码中包含static变量的时候，就会有clinit方法\n\n构造器方法中指令按语句在源文件中出现的顺序执行。\n\n<clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。\n\n- 任何一个类在声明后，都有生成一个构造器，默认是空参构造器\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-8:47\n */\npublic class ClassInitTest {\n    private static int num = 1;\n    static {\n        num = 2;\n        number = 20;\n        System.out.println(num);\n        System.out.println(number);  //报错，非法的前向引用\n    }\n\n    private static int number = 10;\n\n    public static void main(String[] args) {\n        System.out.println(ClassInitTest.num); // 2\n        System.out.println(ClassInitTest.number); // 10\n    }\n}\n```\n\n关于涉及到父类时候的变量赋值过程\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:06\n */\npublic class ClinitTest1 {\n    static class Father {\n        public static int A = 1;\n        static {\n            A = 2;\n        }\n    }\n\n    static class Son extends Father {\n        public static int b = A;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Son.b);\n    }\n}\n```\n\n我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回\n\n```bash\niconst_1\nputstatic #2 <com/atguigu/java/chapter02/ClinitTest1$Father.A>\niconst_2\nputstatic #2 <com/atguigu/java/chapter02/ClinitTest1$Father.A>\nreturn\n```\n\n虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:14\n */\npublic class DeadThreadTest {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t 线程t1开始\");\n            new DeadThread();\n        }, \"t1\").start();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t 线程t2开始\");\n            new DeadThread();\n        }, \"t2\").start();\n    }\n}\nclass DeadThread {\n    static {\n        if (true) {\n            System.out.println(Thread.currentThread().getName() + \"\\t 初始化当前类\");\n            while(true) {\n\n            }\n        }\n    }\n}\n```\n\n上面的代码，输出结果为\n\n```\n线程t1开始\n线程t2开始\n线程t2 初始化当前类\n```\n\n从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程\n\n## 类加载器的分类\n\nJVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。\n\n从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。\n\n无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：\n\n![image-20200705094149223](images/image-20200705094149223.png)\n\n这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。\n\n我们通过一个类，获取它不同的加载器\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-9:47\n */\npublic class ClassLoaderTest {\n    public static void main(String[] args) {\n        // 获取系统类加载器\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n\n        // 获取其上层的：扩展类加载器\n        ClassLoader extClassLoader = systemClassLoader.getParent();\n        System.out.println(extClassLoader);\n\n        // 试图获取 根加载器\n        ClassLoader bootstrapClassLoader = extClassLoader.getParent();\n        System.out.println(bootstrapClassLoader);\n\n        // 获取自定义加载器\n        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\n        System.out.println(classLoader);\n        \n        // 获取String类型的加载器\n        ClassLoader classLoader1 = String.class.getClassLoader();\n        System.out.println(classLoader1);\n    }\n}\n```\n\n得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。\n\n```\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@1540e19d\nnull\nsun.misc.Launcher$AppClassLoader@18b4aac2\nnull \n```\n\n### 虚拟机自带的加载器\n\n#### 启动类加载器（引导类加载器，Bootstrap ClassLoader）\n\n- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。\n- 它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n- 并不继承自ava.lang.ClassLoader，没有父加载器。\n- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n### 扩展类加载器（Extension ClassLoader）\n\n- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。\n- 派生于ClassLoader类\n- 父类加载器为启动类加载器\n- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\n\n### 应用程序类加载器（系统类加载器，AppClassLoader）\n\n- javI语言编写，由sun.misc.LaunchersAppClassLoader实现\n- 派生于ClassLoader类\n- 父类加载器为扩展类加载器\n- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\n- 通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器\n\n### 用户自定义类加载器\n\n在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。\n为什么要自定义类加载器？\n\n- 隔离加载类\n- 修改类加载的方式\n- 扩展加载源\n- 防止源码泄漏\n\n用户自定义类加载器实现步骤：\n\n- 开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求\n- 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中\n- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n### 查看根加载器所能加载的目录\n\n刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下\n\n```java\n/**\n * @author: 陌溪\n * @create: 2020-07-05-10:17\n */\npublic class ClassLoaderTest1 {\n    public static void main(String[] args) {\n        System.out.println(\"*********启动类加载器************\");\n        // 获取BootstrapClassLoader 能够加载的API的路径\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url.toExternalForm());\n        }\n\n        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器\n        ClassLoader classLoader = Provider.class.getClassLoader();\n    }\n}\n```\n\n得到的结果\n\n```\n*********启动类加载器************\nfile:/E:/Software/JDK1.8/Java/jre/lib/resources.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/rt.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/sunrsasign.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jsse.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jce.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/charsets.jar\nfile:/E:/Software/JDK1.8/Java/jre/lib/jfr.jar\nfile:/E:/Software/JDK1.8/Java/jre/classes\nnull\n```\n\n### 关于ClassLoader\n\nClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）\n\n![image-20200705103516138](images/image-20200705103516138.png)\n\nsun.misc.Launcher 它是一个java虚拟机的入口应用\n\n![image-20200705103636003](images/image-20200705103636003.png)\n\n获取ClassLoader的途径\n\n- 获取当前ClassLoader：clazz.getClassLoader()\n- 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()\n- 获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n- 获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n\n## 双亲委派机制\n\nJava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\n\n### 工作原理\n\n- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n![image-20200705105151258](images/image-20200705105151258.png)\n\n### 双亲委派机制举例\n\n当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。\n\n![image-20200705105810107](images/image-20200705105810107.png)\n\n### 沙箱安全机制\n\n自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\n\n### 双亲委派机制的优势\n\n通过上面的例子，我们可以知道，双亲机制可以\n\n- 避免类的重复加载\n- 保护程序安全，防止核心API被随意篡改\n  - 自定义类：java.lang.String\n  - 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）\n\n## 其它\n\n###  如何判断两个class对象是否相同\n\n在JVM中表示两个class对象是否为同一个类存在两个必要条件：\n- 类的完整类名必须一致，包括包名。\n- 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。\n\n换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。\n\nJVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。\n\n### 类的主动使用和被动使用\n\nJava程序对类的使用方式分为：王动使用和被动使用。\n主动使用，又分为七种情况：\n\n- 创建类的实例\n- 访问某个类或接口的静态变量，或者对该静态变量赋值\n- 调用类的静态方法I\n- 反射（比如：Class.forName（\"com.atguigu.Test\"））\n- 初始化一个类的子类\n- Java虚拟机启动时被标明为启动类的类\n- JDK7开始提供的动态语言支持：\n- java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化\n\n除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。","slug":"类加载子系统","published":1,"updated":"2023-12-03T12:57:23.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpphmypn0000ekwf46zva9pa","content":"<h1 id=\"类加载子系统\"><a href=\"#类加载子系统\" class=\"headerlink\" title=\"类加载子系统\"></a>类加载子系统</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><img src=\"/images/image-20200705080719531.png\" alt=\"image-20200705080719531\"></p>\n<p>完整图如下</p>\n<p><img src=\"/images/image-20200705080911284.png\" alt=\"image-20200705080911284\"></p>\n<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>\n<ul>\n<li>类加载器</li>\n<li>执行引擎</li>\n</ul>\n<h2 id=\"类加载器子系统作用\"><a href=\"#类加载器子系统作用\" class=\"headerlink\" title=\"类加载器子系统作用\"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p>\n<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>\n<p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>\n<p><img src=\"/images/image-20200705081813409.png\" alt=\"image-20200705081813409\"></p>\n<ul>\n<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>\n<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li>\n<li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>\n</ul>\n<p><img src=\"/images/image-20200705081913538.png\" alt=\"image-20200705081913538\"></p>\n<h2 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h2><p>例如下面的一段简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 类加载子系统</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:24</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloLoader</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;我已经被加载啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>它的加载过程是怎么样的呢?</p>\n<p><img src=\"/images/image-20200705082255746.png\" alt=\"image-20200705082255746\"></p>\n<p>完整的流程图如下所示</p>\n<p><img src=\"/images/image-20200705082601441.png\" alt=\"image-20200705082601441\"></p>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>通过一个类的全限定名获取定义此类的二进制字节流</p>\n<p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>\n<h3 id=\"加载class文件的方式\"><a href=\"#加载class文件的方式\" class=\"headerlink\" title=\"加载class文件的方式\"></a>加载class文件的方式</h3><ul>\n<li>从本地系统中直接加载</li>\n<li>通过网络获取，典型场景：Web Applet</li>\n<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>\n<li>运行时计算生成，使用最多的是：动态代理技术</li>\n<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>\n<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>\n</ul>\n<h3 id=\"链接阶段\"><a href=\"#链接阶段\" class=\"headerlink\" title=\"链接阶段\"></a>链接阶段</h3><h4 id=\"验证-Verify\"><a href=\"#验证-Verify\" class=\"headerlink\" title=\"验证 Verify\"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>\n<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>\n<blockquote>\n<p>工具：Binary Viewer查看</p>\n</blockquote>\n<p><img src=\"/images/image-20200705084038680.png\" alt=\"image-20200705084038680\"></p>\n<p>如果出现不合法的字节码文件，那么将会验证不通过</p>\n<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>\n<p><img src=\"/images/image-20200705090237078.png\" alt=\"image-20200705090237078\"></p>\n<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>\n<p><img src=\"/images/image-20200705090328171.png\" alt=\"image-20200705090328171\"></p>\n<h3 id=\"准备-Prepare\"><a href=\"#准备-Prepare\" class=\"headerlink\" title=\"准备 Prepare\"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:42</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloApp</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p>\n<p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p>\n<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>\n<p>例如下面这段代码</p>\n<h3 id=\"解析-Resolve\"><a href=\"#解析-Resolve\" class=\"headerlink\" title=\"解析 Resolve\"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p>\n<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>\n<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>\n<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</p>\n<p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>\n<ul>\n<li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>\n</ul>\n<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>\n<p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</p>\n<ul>\n<li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:47</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassInitTest</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        num = <span class=\"hljs-number\">2</span>;<br>        number = <span class=\"hljs-number\">20</span>;<br>        System.out.println(num);<br>        System.out.println(number);  <span class=\"hljs-comment\">//报错，非法的前向引用</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">number</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num); <span class=\"hljs-comment\">// 2</span><br>        System.out.println(ClassInitTest.number); <span class=\"hljs-comment\">// 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关于涉及到父类时候的变量赋值过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:06</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClinitTest1</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            A = <span class=\"hljs-number\">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Father</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> A;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">iconst_1<br>putstatic <span class=\"hljs-comment\">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br>iconst_2<br>putstatic <span class=\"hljs-comment\">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class=\"hljs-built_in\">return</span><br></code></pre></td></tr></table></figure>\n\n<p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:14</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeadThreadTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 线程t1开始&quot;</span>);<br>            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeadThread</span>();<br>        &#125;, <span class=\"hljs-string\">&quot;t1&quot;</span>).start();<br><br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 线程t2开始&quot;</span>);<br>            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeadThread</span>();<br>        &#125;, <span class=\"hljs-string\">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeadThread</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 初始化当前类&quot;</span>);<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码，输出结果为</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">线程<span class=\"hljs-built_in\">t1</span>开始<br>线程<span class=\"hljs-built_in\">t2</span>开始<br>线程<span class=\"hljs-built_in\">t2</span> 初始化当前类<br></code></pre></td></tr></table></figure>\n\n<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p>\n<h2 id=\"类加载器的分类\"><a href=\"#类加载器的分类\" class=\"headerlink\" title=\"类加载器的分类\"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>\n<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>\n<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>\n<p><img src=\"/images/image-20200705094149223.png\" alt=\"image-20200705094149223\"></p>\n<p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p>\n<p>我们通过一个类，获取它不同的加载器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:47</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 获取系统类加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">systemClassLoader</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class=\"hljs-comment\">// 获取其上层的：扩展类加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">extClassLoader</span> <span class=\"hljs-operator\">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<br><br>        <span class=\"hljs-comment\">// 试图获取 根加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">bootstrapClassLoader</span> <span class=\"hljs-operator\">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<br><br>        <span class=\"hljs-comment\">// 获取自定义加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader</span> <span class=\"hljs-operator\">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<br>        <br>        <span class=\"hljs-comment\">// 获取String类型的加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader1</span> <span class=\"hljs-operator\">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\">sun.misc.Launcher$AppClassLoader<span class=\"hljs-symbol\">@18b4aac2</span><br>sun.misc.Launcher$ExtClassLoader<span class=\"hljs-symbol\">@1540e19d</span><br><span class=\"hljs-literal\">null</span><br>sun.misc.Launcher$AppClassLoader<span class=\"hljs-symbol\">@18b4aac2</span><br><span class=\"hljs-literal\">null</span> <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"虚拟机自带的加载器\"><a href=\"#虚拟机自带的加载器\" class=\"headerlink\" title=\"虚拟机自带的加载器\"></a>虚拟机自带的加载器</h3><h4 id=\"启动类加载器（引导类加载器，Bootstrap-ClassLoader）\"><a href=\"#启动类加载器（引导类加载器，Bootstrap-ClassLoader）\" class=\"headerlink\" title=\"启动类加载器（引导类加载器，Bootstrap ClassLoader）\"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>\n<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</li>\n<li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>\n<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>\n<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>\n<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>\n</ul>\n<h3 id=\"扩展类加载器（Extension-ClassLoader）\"><a href=\"#扩展类加载器（Extension-ClassLoader）\" class=\"headerlink\" title=\"扩展类加载器（Extension ClassLoader）\"></a>扩展类加载器（Extension ClassLoader）</h3><ul>\n<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为启动类加载器</li>\n<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>\n</ul>\n<h3 id=\"应用程序类加载器（系统类加载器，AppClassLoader）\"><a href=\"#应用程序类加载器（系统类加载器，AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（系统类加载器，AppClassLoader）\"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul>\n<li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为扩展类加载器</li>\n<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>\n<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>\n<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>\n</ul>\n<h3 id=\"用户自定义类加载器\"><a href=\"#用户自定义类加载器\" class=\"headerlink\" title=\"用户自定义类加载器\"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p>\n<ul>\n<li>隔离加载类</li>\n<li>修改类加载的方式</li>\n<li>扩展加载源</li>\n<li>防止源码泄漏</li>\n</ul>\n<p>用户自定义类加载器实现步骤：</p>\n<ul>\n<li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>\n<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li>\n<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>\n</ul>\n<h3 id=\"查看根加载器所能加载的目录\"><a href=\"#查看根加载器所能加载的目录\" class=\"headerlink\" title=\"查看根加载器所能加载的目录\"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-10:17</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderTest1</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;*********启动类加载器************&quot;</span>);<br>        <span class=\"hljs-comment\">// 获取BootstrapClassLoader 能够加载的API的路径</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class=\"hljs-keyword\">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader</span> <span class=\"hljs-operator\">=</span> Provider.class.getClassLoader();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到的结果</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">*********启动类加载器************<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/resources.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/rt.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/sunrsasign.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jsse.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jce.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/charsets.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jfr.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>classes<br><span class=\"hljs-keyword\">null</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"关于ClassLoader\"><a href=\"#关于ClassLoader\" class=\"headerlink\" title=\"关于ClassLoader\"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>\n<p><img src=\"/images/image-20200705103516138.png\" alt=\"image-20200705103516138\"></p>\n<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>\n<p><img src=\"/images/image-20200705103636003.png\" alt=\"image-20200705103636003\"></p>\n<p>获取ClassLoader的途径</p>\n<ul>\n<li>获取当前ClassLoader：clazz.getClassLoader()</li>\n<li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li>\n<li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li>\n<li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li>\n</ul>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ul>\n<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>\n<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>\n<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>\n</ul>\n<p><img src=\"/images/image-20200705105151258.png\" alt=\"image-20200705105151258\"></p>\n<h3 id=\"双亲委派机制举例\"><a href=\"#双亲委派机制举例\" class=\"headerlink\" title=\"双亲委派机制举例\"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p>\n<p><img src=\"/images/image-20200705105810107.png\" alt=\"image-20200705105810107\"></p>\n<h3 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>\n<h3 id=\"双亲委派机制的优势\"><a href=\"#双亲委派机制的优势\" class=\"headerlink\" title=\"双亲委派机制的优势\"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>\n<ul>\n<li>避免类的重复加载</li>\n<li>保护程序安全，防止核心API被随意篡改<ul>\n<li>自定义类：java.lang.String</li>\n<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"如何判断两个class对象是否相同\"><a href=\"#如何判断两个class对象是否相同\" class=\"headerlink\" title=\"如何判断两个class对象是否相同\"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>\n<ul>\n<li>类的完整类名必须一致，包括包名。</li>\n<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>\n</ul>\n<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>\n<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>\n<h3 id=\"类的主动使用和被动使用\"><a href=\"#类的主动使用和被动使用\" class=\"headerlink\" title=\"类的主动使用和被动使用\"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p>\n<ul>\n<li>创建类的实例</li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>\n<li>调用类的静态方法I</li>\n<li>反射（比如：Class.forName（”com.atguigu.Test”））</li>\n<li>初始化一个类的子类</li>\n<li>Java虚拟机启动时被标明为启动类的类</li>\n<li>JDK7开始提供的动态语言支持：</li>\n<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ul>\n<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类加载子系统\"><a href=\"#类加载子系统\" class=\"headerlink\" title=\"类加载子系统\"></a>类加载子系统</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><img src=\"/images/image-20200705080719531.png\" alt=\"image-20200705080719531\"></p>\n<p>完整图如下</p>\n<p><img src=\"/images/image-20200705080911284.png\" alt=\"image-20200705080911284\"></p>\n<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>\n<ul>\n<li>类加载器</li>\n<li>执行引擎</li>\n</ul>\n<h2 id=\"类加载器子系统作用\"><a href=\"#类加载器子系统作用\" class=\"headerlink\" title=\"类加载器子系统作用\"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p>\n<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>\n<p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>\n<p><img src=\"/images/image-20200705081813409.png\" alt=\"image-20200705081813409\"></p>\n<ul>\n<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>\n<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li>\n<li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>\n</ul>\n<p><img src=\"/images/image-20200705081913538.png\" alt=\"image-20200705081913538\"></p>\n<h2 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h2><p>例如下面的一段简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 类加载子系统</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:24</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloLoader</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;我已经被加载啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>它的加载过程是怎么样的呢?</p>\n<p><img src=\"/images/image-20200705082255746.png\" alt=\"image-20200705082255746\"></p>\n<p>完整的流程图如下所示</p>\n<p><img src=\"/images/image-20200705082601441.png\" alt=\"image-20200705082601441\"></p>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>通过一个类的全限定名获取定义此类的二进制字节流</p>\n<p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>\n<h3 id=\"加载class文件的方式\"><a href=\"#加载class文件的方式\" class=\"headerlink\" title=\"加载class文件的方式\"></a>加载class文件的方式</h3><ul>\n<li>从本地系统中直接加载</li>\n<li>通过网络获取，典型场景：Web Applet</li>\n<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>\n<li>运行时计算生成，使用最多的是：动态代理技术</li>\n<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>\n<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>\n</ul>\n<h3 id=\"链接阶段\"><a href=\"#链接阶段\" class=\"headerlink\" title=\"链接阶段\"></a>链接阶段</h3><h4 id=\"验证-Verify\"><a href=\"#验证-Verify\" class=\"headerlink\" title=\"验证 Verify\"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>\n<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>\n<blockquote>\n<p>工具：Binary Viewer查看</p>\n</blockquote>\n<p><img src=\"/images/image-20200705084038680.png\" alt=\"image-20200705084038680\"></p>\n<p>如果出现不合法的字节码文件，那么将会验证不通过</p>\n<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>\n<p><img src=\"/images/image-20200705090237078.png\" alt=\"image-20200705090237078\"></p>\n<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>\n<p><img src=\"/images/image-20200705090328171.png\" alt=\"image-20200705090328171\"></p>\n<h3 id=\"准备-Prepare\"><a href=\"#准备-Prepare\" class=\"headerlink\" title=\"准备 Prepare\"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:42</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloApp</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p>\n<p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p>\n<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>\n<p>例如下面这段代码</p>\n<h3 id=\"解析-Resolve\"><a href=\"#解析-Resolve\" class=\"headerlink\" title=\"解析 Resolve\"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p>\n<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>\n<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>\n<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</p>\n<p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>\n<ul>\n<li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>\n</ul>\n<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>\n<p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</p>\n<ul>\n<li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-8:47</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassInitTest</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        num = <span class=\"hljs-number\">2</span>;<br>        number = <span class=\"hljs-number\">20</span>;<br>        System.out.println(num);<br>        System.out.println(number);  <span class=\"hljs-comment\">//报错，非法的前向引用</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">number</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num); <span class=\"hljs-comment\">// 2</span><br>        System.out.println(ClassInitTest.number); <span class=\"hljs-comment\">// 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关于涉及到父类时候的变量赋值过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:06</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClinitTest1</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            A = <span class=\"hljs-number\">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Father</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> A;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">iconst_1<br>putstatic <span class=\"hljs-comment\">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br>iconst_2<br>putstatic <span class=\"hljs-comment\">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class=\"hljs-built_in\">return</span><br></code></pre></td></tr></table></figure>\n\n<p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:14</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeadThreadTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 线程t1开始&quot;</span>);<br>            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeadThread</span>();<br>        &#125;, <span class=\"hljs-string\">&quot;t1&quot;</span>).start();<br><br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 线程t2开始&quot;</span>);<br>            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeadThread</span>();<br>        &#125;, <span class=\"hljs-string\">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeadThread</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;\\t 初始化当前类&quot;</span>);<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码，输出结果为</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">线程<span class=\"hljs-built_in\">t1</span>开始<br>线程<span class=\"hljs-built_in\">t2</span>开始<br>线程<span class=\"hljs-built_in\">t2</span> 初始化当前类<br></code></pre></td></tr></table></figure>\n\n<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p>\n<h2 id=\"类加载器的分类\"><a href=\"#类加载器的分类\" class=\"headerlink\" title=\"类加载器的分类\"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>\n<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>\n<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>\n<p><img src=\"/images/image-20200705094149223.png\" alt=\"image-20200705094149223\"></p>\n<p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p>\n<p>我们通过一个类，获取它不同的加载器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-9:47</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 获取系统类加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">systemClassLoader</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class=\"hljs-comment\">// 获取其上层的：扩展类加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">extClassLoader</span> <span class=\"hljs-operator\">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<br><br>        <span class=\"hljs-comment\">// 试图获取 根加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">bootstrapClassLoader</span> <span class=\"hljs-operator\">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<br><br>        <span class=\"hljs-comment\">// 获取自定义加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader</span> <span class=\"hljs-operator\">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<br>        <br>        <span class=\"hljs-comment\">// 获取String类型的加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader1</span> <span class=\"hljs-operator\">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\">sun.misc.Launcher$AppClassLoader<span class=\"hljs-symbol\">@18b4aac2</span><br>sun.misc.Launcher$ExtClassLoader<span class=\"hljs-symbol\">@1540e19d</span><br><span class=\"hljs-literal\">null</span><br>sun.misc.Launcher$AppClassLoader<span class=\"hljs-symbol\">@18b4aac2</span><br><span class=\"hljs-literal\">null</span> <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"虚拟机自带的加载器\"><a href=\"#虚拟机自带的加载器\" class=\"headerlink\" title=\"虚拟机自带的加载器\"></a>虚拟机自带的加载器</h3><h4 id=\"启动类加载器（引导类加载器，Bootstrap-ClassLoader）\"><a href=\"#启动类加载器（引导类加载器，Bootstrap-ClassLoader）\" class=\"headerlink\" title=\"启动类加载器（引导类加载器，Bootstrap ClassLoader）\"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>\n<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</li>\n<li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>\n<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>\n<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>\n<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>\n</ul>\n<h3 id=\"扩展类加载器（Extension-ClassLoader）\"><a href=\"#扩展类加载器（Extension-ClassLoader）\" class=\"headerlink\" title=\"扩展类加载器（Extension ClassLoader）\"></a>扩展类加载器（Extension ClassLoader）</h3><ul>\n<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为启动类加载器</li>\n<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>\n</ul>\n<h3 id=\"应用程序类加载器（系统类加载器，AppClassLoader）\"><a href=\"#应用程序类加载器（系统类加载器，AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（系统类加载器，AppClassLoader）\"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul>\n<li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为扩展类加载器</li>\n<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>\n<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>\n<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>\n</ul>\n<h3 id=\"用户自定义类加载器\"><a href=\"#用户自定义类加载器\" class=\"headerlink\" title=\"用户自定义类加载器\"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p>\n<ul>\n<li>隔离加载类</li>\n<li>修改类加载的方式</li>\n<li>扩展加载源</li>\n<li>防止源码泄漏</li>\n</ul>\n<p>用户自定义类加载器实现步骤：</p>\n<ul>\n<li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>\n<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li>\n<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>\n</ul>\n<h3 id=\"查看根加载器所能加载的目录\"><a href=\"#查看根加载器所能加载的目录\" class=\"headerlink\" title=\"查看根加载器所能加载的目录\"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-10:17</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderTest1</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;*********启动类加载器************&quot;</span>);<br>        <span class=\"hljs-comment\">// 获取BootstrapClassLoader 能够加载的API的路径</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class=\"hljs-keyword\">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span><br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">classLoader</span> <span class=\"hljs-operator\">=</span> Provider.class.getClassLoader();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到的结果</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">*********启动类加载器************<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/resources.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/rt.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/sunrsasign.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jsse.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jce.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/charsets.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>lib/jfr.jar<br><span class=\"hljs-keyword\">file</span>:<span class=\"hljs-regexp\">/E:/</span>Software<span class=\"hljs-regexp\">/JDK1.8/</span>Java<span class=\"hljs-regexp\">/jre/</span>classes<br><span class=\"hljs-keyword\">null</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"关于ClassLoader\"><a href=\"#关于ClassLoader\" class=\"headerlink\" title=\"关于ClassLoader\"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>\n<p><img src=\"/images/image-20200705103516138.png\" alt=\"image-20200705103516138\"></p>\n<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>\n<p><img src=\"/images/image-20200705103636003.png\" alt=\"image-20200705103636003\"></p>\n<p>获取ClassLoader的途径</p>\n<ul>\n<li>获取当前ClassLoader：clazz.getClassLoader()</li>\n<li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li>\n<li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li>\n<li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li>\n</ul>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ul>\n<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>\n<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>\n<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>\n</ul>\n<p><img src=\"/images/image-20200705105151258.png\" alt=\"image-20200705105151258\"></p>\n<h3 id=\"双亲委派机制举例\"><a href=\"#双亲委派机制举例\" class=\"headerlink\" title=\"双亲委派机制举例\"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p>\n<p><img src=\"/images/image-20200705105810107.png\" alt=\"image-20200705105810107\"></p>\n<h3 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>\n<h3 id=\"双亲委派机制的优势\"><a href=\"#双亲委派机制的优势\" class=\"headerlink\" title=\"双亲委派机制的优势\"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>\n<ul>\n<li>避免类的重复加载</li>\n<li>保护程序安全，防止核心API被随意篡改<ul>\n<li>自定义类：java.lang.String</li>\n<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"如何判断两个class对象是否相同\"><a href=\"#如何判断两个class对象是否相同\" class=\"headerlink\" title=\"如何判断两个class对象是否相同\"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>\n<ul>\n<li>类的完整类名必须一致，包括包名。</li>\n<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>\n</ul>\n<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>\n<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>\n<h3 id=\"类的主动使用和被动使用\"><a href=\"#类的主动使用和被动使用\" class=\"headerlink\" title=\"类的主动使用和被动使用\"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p>\n<ul>\n<li>创建类的实例</li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>\n<li>调用类的静态方法I</li>\n<li>反射（比如：Class.forName（”com.atguigu.Test”））</li>\n<li>初始化一个类的子类</li>\n<li>Java虚拟机启动时被标明为启动类的类</li>\n<li>JDK7开始提供的动态语言支持：</li>\n<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ul>\n<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>\n"},{"title":"JVM_运行时数据区概述及线程","date":"2023-12-03T13:03:36.000Z","_content":"\n\n# 运行时数据区概述及线程\n\n## 前言\n\n本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段\n\n![image-20200705111640511](images/image-20200705111640511.png)\n\n当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\n\n![image-20200705111843003](images/image-20200705111843003.png)\n\n也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品\n\n![image-20200705112036630](images/image-20200705112036630.png)\n\n内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。\n\n> 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁\n\n运行时数据区的完整图\n\n![image-20200705112416101](images/image-20200705112416101.png)\n\nJava虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\n\n- 每个线程：独立包括程序计数器、栈、本地栈。\n- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）\n\n![image-20200705112601211](images/image-20200705112601211.png)\n\n## 线程\n\n线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。\n在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。\n\n- 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。\n\n操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。\n\n### JVM系统线程\n\n如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|\n这些主要的后台系统线程在Hotspot JVM里主要是以下几个：\n\n- 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括\"stop-the-world\"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\n- 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\n- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。\n- 编译线程：这种线程在运行时会将字节码编译成到本地代码。\n- 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。\n\n### ","source":"_posts/JVM-运行时数据区概述及线程.md","raw":"---\ntitle: JVM_运行时数据区概述及线程\ndate: 2023-12-03 21:03:36\ntags: jvm\ncategories: java\n---\n\n\n# 运行时数据区概述及线程\n\n## 前言\n\n本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段\n\n![image-20200705111640511](images/image-20200705111640511.png)\n\n当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\n\n![image-20200705111843003](images/image-20200705111843003.png)\n\n也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品\n\n![image-20200705112036630](images/image-20200705112036630.png)\n\n内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。\n\n> 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁\n\n运行时数据区的完整图\n\n![image-20200705112416101](images/image-20200705112416101.png)\n\nJava虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\n\n- 每个线程：独立包括程序计数器、栈、本地栈。\n- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）\n\n![image-20200705112601211](images/image-20200705112601211.png)\n\n## 线程\n\n线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。\n在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。\n\n- 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。\n\n操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。\n\n### JVM系统线程\n\n如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|\n这些主要的后台系统线程在Hotspot JVM里主要是以下几个：\n\n- 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括\"stop-the-world\"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\n- 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\n- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。\n- 编译线程：这种线程在运行时会将字节码编译成到本地代码。\n- 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。\n\n### ","slug":"JVM-运行时数据区概述及线程","published":1,"updated":"2023-12-03T13:04:35.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpphw94t0000xcwfa31scsxq","content":"<h1 id=\"运行时数据区概述及线程\"><a href=\"#运行时数据区概述及线程\" class=\"headerlink\" title=\"运行时数据区概述及线程\"></a>运行时数据区概述及线程</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>\n<p><img src=\"/images/image-20200705111640511.png\" alt=\"image-20200705111640511\"></p>\n<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\n<p><img src=\"/images/image-20200705111843003.png\" alt=\"image-20200705111843003\"></p>\n<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>\n<p><img src=\"/images/image-20200705112036630.png\" alt=\"image-20200705112036630\"></p>\n<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>\n<blockquote>\n<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>\n</blockquote>\n<p>运行时数据区的完整图</p>\n<p><img src=\"/images/image-20200705112416101.png\" alt=\"image-20200705112416101\"></p>\n<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>\n<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>\n<ul>\n<li>每个线程：独立包括程序计数器、栈、本地栈。</li>\n<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>\n</ul>\n<p><img src=\"/images/image-20200705112601211.png\" alt=\"image-20200705112601211\"></p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>\n<ul>\n<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>\n</ul>\n<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p>\n<h3 id=\"JVM系统线程\"><a href=\"#JVM系统线程\" class=\"headerlink\" title=\"JVM系统线程\"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>\n<ul>\n<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>\n<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>\n<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>\n<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>\n<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"运行时数据区概述及线程\"><a href=\"#运行时数据区概述及线程\" class=\"headerlink\" title=\"运行时数据区概述及线程\"></a>运行时数据区概述及线程</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>\n<p><img src=\"/images/image-20200705111640511.png\" alt=\"image-20200705111640511\"></p>\n<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\n<p><img src=\"/images/image-20200705111843003.png\" alt=\"image-20200705111843003\"></p>\n<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>\n<p><img src=\"/images/image-20200705112036630.png\" alt=\"image-20200705112036630\"></p>\n<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>\n<blockquote>\n<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>\n</blockquote>\n<p>运行时数据区的完整图</p>\n<p><img src=\"/images/image-20200705112416101.png\" alt=\"image-20200705112416101\"></p>\n<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>\n<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>\n<ul>\n<li>每个线程：独立包括程序计数器、栈、本地栈。</li>\n<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>\n</ul>\n<p><img src=\"/images/image-20200705112601211.png\" alt=\"image-20200705112601211\"></p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>\n<ul>\n<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>\n</ul>\n<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p>\n<h3 id=\"JVM系统线程\"><a href=\"#JVM系统线程\" class=\"headerlink\" title=\"JVM系统线程\"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>\n<ul>\n<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>\n<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>\n<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>\n<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>\n<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"title":"程序计数器","date":"2023-12-03T13:09:43.000Z","_content":"\n# 程序计数器\n\n## 介绍\n\nJVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。\n\n![image-20200705155551919](images/image-20200705155551919.png)\n\n它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n\n在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\n\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。\n\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。\n\n## 作用\n\nPC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。\n\n![image-20200705155728557](images/image-20200705155728557.png)\n\n## 代码演示\n\n我们首先写一个简单的代码\n\n```java\n/**程序计数器\n * @author: 陌溪\n * @create: 2020-07-05-16:01\n */\npublic class PCRegisterTest {\n    public static void main(String[] args) {\n        int i = 10;\n        int j = 20;\n        int k = i + j;\n    }\n}\n```\n\n然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。\n\n```bash\n0: bipush        10\n2: istore_1\n3: bipush        20\n5: istore_2\n6: iload_1\n7: iload_2\n8: iadd\n9: istore_3\n10: return\n```\n\n通过PC寄存器，我们就可以知道当前程序执行到哪一步了 ![image-20200705161007423](images/image-20200705161007423.png)\n\n\n\n## 使用PC寄存器存储字节码指令地址有什么用呢？\n\n因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\n\nJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n\n![image-20200705161409533](images/image-20200705161409533.png)\n\n## PC寄存器为什么被设定为私有的？\n\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n\n由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\n\n这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\n\n![image-20200705161812542](images/image-20200705161812542.png)\n\n## CPU时间片\n\nCPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\n\n在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n\n但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n\n![image-20200705161849557](images/image-20200705161849557.png)","source":"_posts/程序计数器.md","raw":"---\ntitle: 程序计数器\ndate: 2023-12-03 21:09:43\ntags: jvm\ncategories: java\n---\n\n# 程序计数器\n\n## 介绍\n\nJVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。\n\n![image-20200705155551919](images/image-20200705155551919.png)\n\n它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n\n在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\n\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。\n\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。\n\n## 作用\n\nPC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。\n\n![image-20200705155728557](images/image-20200705155728557.png)\n\n## 代码演示\n\n我们首先写一个简单的代码\n\n```java\n/**程序计数器\n * @author: 陌溪\n * @create: 2020-07-05-16:01\n */\npublic class PCRegisterTest {\n    public static void main(String[] args) {\n        int i = 10;\n        int j = 20;\n        int k = i + j;\n    }\n}\n```\n\n然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。\n\n```bash\n0: bipush        10\n2: istore_1\n3: bipush        20\n5: istore_2\n6: iload_1\n7: iload_2\n8: iadd\n9: istore_3\n10: return\n```\n\n通过PC寄存器，我们就可以知道当前程序执行到哪一步了 ![image-20200705161007423](images/image-20200705161007423.png)\n\n\n\n## 使用PC寄存器存储字节码指令地址有什么用呢？\n\n因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\n\nJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n\n![image-20200705161409533](images/image-20200705161409533.png)\n\n## PC寄存器为什么被设定为私有的？\n\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n\n由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\n\n这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\n\n![image-20200705161812542](images/image-20200705161812542.png)\n\n## CPU时间片\n\nCPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\n\n在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n\n但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n\n![image-20200705161849557](images/image-20200705161849557.png)","slug":"程序计数器","published":1,"updated":"2023-12-03T13:10:33.556Z","_id":"clppi1yvu0003xcwfej0tcc1h","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>\n<p><img src=\"/images/image-20200705155551919.png\" alt=\"image-20200705155551919\"></p>\n<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>\n<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>\n<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>\n<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>\n<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>\n<p><img src=\"/images/image-20200705155728557.png\" alt=\"image-20200705155728557\"></p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>我们首先写一个简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**程序计数器</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-16:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PCRegisterTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">0: bipush        10<br>2: istore_1<br>3: bipush        20<br>5: istore_2<br>6: iload_1<br>7: iload_2<br>8: iadd<br>9: istore_3<br>10: <span class=\"hljs-built_in\">return</span><br></code></pre></td></tr></table></figure>\n\n<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 <img src=\"/images/image-20200705161007423.png\" alt=\"image-20200705161007423\"></p>\n<h2 id=\"使用PC寄存器存储字节码指令地址有什么用呢？\"><a href=\"#使用PC寄存器存储字节码指令地址有什么用呢？\" class=\"headerlink\" title=\"使用PC寄存器存储字节码指令地址有什么用呢？\"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>\n<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<p><img src=\"/images/image-20200705161409533.png\" alt=\"image-20200705161409533\"></p>\n<h2 id=\"PC寄存器为什么被设定为私有的？\"><a href=\"#PC寄存器为什么被设定为私有的？\" class=\"headerlink\" title=\"PC寄存器为什么被设定为私有的？\"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>\n<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>\n<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>\n<p><img src=\"/images/image-20200705161812542.png\" alt=\"image-20200705161812542\"></p>\n<h2 id=\"CPU时间片\"><a href=\"#CPU时间片\" class=\"headerlink\" title=\"CPU时间片\"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>\n<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>\n<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>\n<p><img src=\"/images/image-20200705161849557.png\" alt=\"image-20200705161849557\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>\n<p><img src=\"/images/image-20200705155551919.png\" alt=\"image-20200705155551919\"></p>\n<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>\n<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>\n<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>\n<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>\n<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>\n<p><img src=\"/images/image-20200705155728557.png\" alt=\"image-20200705155728557\"></p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>我们首先写一个简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**程序计数器</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-05-16:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PCRegisterTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">20</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">0: bipush        10<br>2: istore_1<br>3: bipush        20<br>5: istore_2<br>6: iload_1<br>7: iload_2<br>8: iadd<br>9: istore_3<br>10: <span class=\"hljs-built_in\">return</span><br></code></pre></td></tr></table></figure>\n\n<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 <img src=\"/images/image-20200705161007423.png\" alt=\"image-20200705161007423\"></p>\n<h2 id=\"使用PC寄存器存储字节码指令地址有什么用呢？\"><a href=\"#使用PC寄存器存储字节码指令地址有什么用呢？\" class=\"headerlink\" title=\"使用PC寄存器存储字节码指令地址有什么用呢？\"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>\n<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<p><img src=\"/images/image-20200705161409533.png\" alt=\"image-20200705161409533\"></p>\n<h2 id=\"PC寄存器为什么被设定为私有的？\"><a href=\"#PC寄存器为什么被设定为私有的？\" class=\"headerlink\" title=\"PC寄存器为什么被设定为私有的？\"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>\n<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>\n<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>\n<p><img src=\"/images/image-20200705161812542.png\" alt=\"image-20200705161812542\"></p>\n<h2 id=\"CPU时间片\"><a href=\"#CPU时间片\" class=\"headerlink\" title=\"CPU时间片\"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>\n<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>\n<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>\n<p><img src=\"/images/image-20200705161849557.png\" alt=\"image-20200705161849557\"></p>\n"},{"title":"java堆","date":"2023-12-03T13:14:03.000Z","_content":"\n# 堆\n\n## 堆的核心概念\n\n堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。\n\n![image-20200706195127740](images/image-20200706195127740.png)\n\n一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\n\nJava堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n\n- 堆内存的大小是可以调节的。\n\n《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n\n所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。\n\n> -Xms10m：最小堆内存\n>\n> -Xmx10m：最大堆内存\n\n下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件\n\n![image-20200706200739392](images/image-20200706200739392.png)\n\n《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）\n\n我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。\n\n- 因为还有一些对象是在栈上分配的\n\n数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\n\n在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n\n- 也就是触发了GC的时候，才会进行回收\n- 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word\n\n堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\n\n![image-20200706201904057](images/image-20200706201904057.png)\n\n### 堆内存细分\n\nJava 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区\n\n- Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区\n- Tenure generation space 养老区 Old/Tenure\n- Permanent Space永久区   Perm\n\nJava 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间\n- Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区\n- Tenure generation space 养老区  Old/Tenure\n- Meta Space  元空间   Meta\n\n约定：新生区 -> 新生代 -> 年轻代   、  养老区 -> 老年区 -> 老年代、 永久区 -> 永久代\n\n![image-20200706203419496](images/image-20200706203419496.png)\n\n堆空间内部结构，JDK1.8之前从永久代  替换成 元空间\n\n![image-20200706203835403](images/image-20200706203835403.png)\n\n\n\n\n\n## 设置堆内存大小与OOM\n\nJava堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项\"-Xmx\"和\"-Xms\"来进行设置。\n\n- “-Xms\"用于表示堆区的起始内存，等价于-xx:InitialHeapSize\n- “-Xmx\"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize\n\n一旦堆区中的内存大小超过“-xmx\"所指定的最大内存时，将会抛出outofMemoryError异常。\n\n通常会将-Xms和-Xmx两个参数配置相同的值，其目的是**为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**。\n\n默认情况下\n\n- 初始内存大小：物理电脑内存大小/64\n\n- 最大内存大小：物理电脑内存大小/4\n\n```java\n/**\n * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小\n *  -X：是jvm运行参数\n *  ms：memory start\n * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小\n *\n * @author: 陌溪\n * @create: 2020-07-06-20:44\n */\npublic class HeapSpaceInitial {\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的堆内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机试图使用的最大堆内存\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n        System.out.println(\"-Xms:\" + initialMemory + \"M\");\n        System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n    }\n}\n```\n\n输出结果\n\n```\n-Xms:245M\n-Xmx:3614M\n```\n\n如何查看堆内存的内存分配情况\n\n```\njps  ->  jstat -gc 进程id\n```\n\n![image-20200706205756045](images/image-20200706205756045.png)\n\n```\n-XX:+PrintGCDetails\n```\n\n![image-20200706205821919](images/image-20200706205821919.png)\n\n### OutOfMemory举例\n\n![image-20200706205947535](images/image-20200706205947535.png)\n\n![image-20200706210000461](images/image-20200706210000461.png)\n\n我们简单的写一个OOM例子\n\n```java\n/**\n * OOM测试\n *\n * @author: 陌溪\n * @create: 2020-07-06-21:11\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        while(true) {\n            list.add(999999999);\n        }\n    }\n}\n\n```\n\n然后设置启动参数\n\n```\n-Xms10m -Xmx:10m\n```\n\n运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM\n\n![image-20200706211652779](images/image-20200706211652779.png)\n\n## 年轻代与老年代\n\n存储在JVM中的Java对象可以被划分为两类：\n- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n  - 生命周期短的，及时回收即可\n- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致\n\nJava堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）\n\n其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）\n\n![image-20200707075847954](images/image-20200707075847954.png)\n\n下面这参数开发中一般不会调：\n\n![image-20200707080154039](images/image-20200707080154039.png)\n\n- Eden：From：to ->  8:1:1\n- 新生代：老年代  - >  1 : 2\n\n配置新生代与老年代在堆结构的占比。\n\n- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n\n- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n> 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优\n\n在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8\n\n几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）\n\n>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n>\n>可以使用选项\"-Xmn\"设置新生代最大内存大小\n>\n>这个参数一般使用默认值就可以了。\n\n![image-20200707084208115](images/image-20200707084208115.png)\n\n## 图解对象分配过程\n\n### 概念\n\n为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\n- new的对象先放伊甸园区。此区有大小限制。\n- 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n- 然后将伊甸园中的剩余对象移动到幸存者0区。\n- 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n- 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n- 啥时候能去养老区呢？可以设置次数。默认是15次。\n- 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理\n- 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。\n\n可以设置参数：-Xx:MaxTenuringThreshold= N进行设置\n\n### 图解过程\n\n我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作\n\n![image-20200707084714886](images/image-20200707084714886.png)\n\n当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。\n\n同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1\n\n![image-20200707085232646](images/image-20200707085232646.png)\n\n我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中\n\n![image-20200707085737207](images/image-20200707085737207.png)\n\n### 思考：幸存区区满了后？\n\n特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作\n\n如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代\n\n> 举例：以当兵为例，正常人的晋升可能是 ：  新兵 -> 班长 -> 排长 -> 连长\n>\n> 但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -> 排长\n\n### 对象分配的特殊情况\n\n![image-20200707091058346](images/image-20200707091058346.png)\n\n### 代码演示对象分配过程\n\n我们不断的创建大对象\n\n```java\n/**\n * 代码演示对象创建过程\n *\n * @author: 陌溪\n * @create: 2020-07-07-9:16\n */\npublic class HeapInstanceTest {\n    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];\n    public static void main(String[] args) throws InterruptedException {\n        ArrayList<HeapInstanceTest> list = new ArrayList<>();\n        while (true) {\n            list.add(new HeapInstanceTest());\n            Thread.sleep(10);\n        }\n    }\n}\n```\n\n然后设置JVM参数\n\n```bash\n-Xms600m -Xmx600m\n```\n\n然后cmd输入下面命令，打开VisualVM图形化界面\n\n```\njvisualvm\n```\n\n然后通过执行上面代码，通过VisualGC进行动态化查看\n\n![垃圾回收](images/垃圾回收.gif)\n\n最终，在老年代和新生代都满了，就出现OOM\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat com.atguigu.java.chapter08.HeapInstanceTest.<init>(HeapInstanceTest.java:13)\n\tat com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)\n```\n\n### 常用的调优工具\n\n- JDK命令行\n- Eclipse：Memory Analyzer Tool\n- Jconsole\n- Visual VM（实时监控  推荐~）\n- Jprofiler（推荐~）\n- Java Flight Recorder（实时监控）\n- GCViewer\n- GCEasy\n\n### 总结\n\n- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to\n- 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集\n- 新生代采用复制算法的目的：是为了减少内碎片\n\n## Minor GC，MajorGC、Full GC\n\n- Minor GC：新生代的GC\n- Major GC：老年代的GC\n- Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集\n\n>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题\n>\n>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上\n\nJVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\n\n部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：\n\n- 新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集\n- 老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。\n  - 目前，只有CMSGC会有单独收集老年代的行为。\n  - 注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。\n- 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。\n  - 目前，只有G1 GC会有这种行为\n\n整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。\n\n### Minor GC\n\n当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）\n\n因为Java对象大多都具备 **朝生夕灭** 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n\nMinor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行\n\n> STW：stop the word\n\n![image-20200707095606813](images/image-20200707095606813.png)\n\n### Major GC\n\n指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了\n\n出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）\n\n- 也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC\n\nMajor GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了\n\n### Full GC\n\n触发Fu11GC执行的情况有如下五种：\n\n- 调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行\n- 老年代空间不足\n- 方法区空间不足\n- 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n- 由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些\n\n\n\n### GC 举例\n\n我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的\n\n```java\n/**\n * GC测试\n *\n * @author: 陌溪\n * @create: 2020-07-07-10:01\n */\npublic class GCTest {\n    public static void main(String[] args) {\n        int i = 0;\n        try {\n            List<String> list = new ArrayList<>();\n            String a = \"mogu blog\";\n            while(true) {\n                list.add(a);\n                a = a + a;\n                i++;\n            }\n        }catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n}\n```\n\n设置JVM启动参数\n\n```bash\n-Xms10m -Xmx10m -XX:+PrintGCDetails\n```\n\n打印出的日志\n\n```\n[GC (Allocation Failure) [PSYoungGen: 2038K->500K(2560K)] 2038K->797K(9728K), 0.3532002 secs] [Times: user=0.01 sys=0.00, real=0.36 secs] \n[GC (Allocation Failure) [PSYoungGen: 2108K->480K(2560K)] 2405K->1565K(9728K), 0.0014069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 2288K->0K(2560K)] [ParOldGen: 6845K->5281K(7168K)] 9133K->5281K(9728K), [Metaspace: 3482K->3482K(1056768K)], 0.0058675 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \n[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 5281K->5281K(9728K), 0.0002857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 5281K->5263K(7168K)] 5281K->5263K(9728K), [Metaspace: 3482K->3482K(1056768K)], 0.0058564 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\n  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)\n  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\n  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\n ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\n  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)\n Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K\n  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K\n  \n  Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat java.util.Arrays.copyOfRange(Arrays.java:3664)\n\tat java.lang.String.<init>(String.java:207)\n\tat java.lang.StringBuilder.toString(StringBuilder.java:407)\n\tat com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)\n```\n\n触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常\n\n## 堆空间分代思想\n\n 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。\n\n>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。\n>老年代：存放新生代中经历多次GC仍然存活的对象。\n\n![image-20200707101511025](images/image-20200707101511025.png)\n\n其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n![image-20200707101543871](images/image-20200707101543871.png)\n\n\n\n## 内存分配策略\n\n如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代\n\n对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置\n\n针对不同年龄段的对象分配原则如下所示：\n\n- 优先分配到Eden\n  - 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢\n- 大对象直接分配到老年代\n  - 尽量避免程序中出现过多的大对象\n- 长期存活的对象分配到老年代\n- 动态对象年龄判断\n  - 如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。\n\n空间分配担保： -Xx:HandlePromotionFailure\n\n- 也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。\n\n## 为对象分配内存：TLAB\n\n### 问题：堆空间都是共享的么？\n\n不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占\n\n### 为什么有TLAB？\n\nTLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区\n\n堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n\n由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\n\n为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n\n### 什么是TLAB\n\n从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。\n\n多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n\n据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\n\n![image-20200707103547712](images/image-20200707103547712.png)\n\n尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。\n\n在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。\n\n默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。\n\n一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。\n\n### TLAB分配过程\n\n对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配\n\n![image-20200707104253530](images/image-20200707104253530.png)\n\n## 小结：堆空间的参数设置\n\n- -XX：+PrintFlagsInitial：查看所有的参数的默认初始值\n- -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）\n- -Xms：初始堆空间内存（默认为物理内存的1/64）\n- -Xmx：最大堆空间内存（默认为物理内存的1/4）\n- -Xmn：设置新生代的大小。（初始值及最大值）\n- -XX:NewRatio：配置新生代与老年代在堆结构的占比\n\n- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例\n- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄\n- -XX：+PrintGCDetails：输出详细的GC处理日志\n  - 打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc\n- -XX:HandlePromotionFalilure：是否设置空间分配担保\n\n\n\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I\n\n- 如果大于，则此次Minor GC是安全的\n- 如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。\n  - 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。\n  - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n  - 如果小于，则改为进行一次FullGC。\n  - 如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。\n\n在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。\n\n## 堆是分配对象的唯一选择么？\n\n### 逃逸分析\n\n在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：\n\n随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\n\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n\n此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\n\n如何将堆上的对象分配到栈，需要使用逃逸分析手段。\n\n这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：\n\n- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\n- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。\n\n#### 逃逸分析举例\n\n没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析\n\n```java\npublic void my_method() {\n    V v = new V();\n    // use v\n    // ....\n    v = null;\n}\n```\n\n针对下面的代码\n\n```java\npublic static StringBuffer createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n```\n\n如果想要StringBuffer sb不发生逃逸，可以这样写\n\n```java\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n```\n\n完整的逃逸分析代码举例\n\n```java\n/**\n * 逃逸分析\n * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n * @author: 陌溪\n * @create: 2020-07-07-20:05\n */\npublic class EscapeAnalysis {\n\n    public EscapeAnalysis obj;\n\n    /**\n     * 方法返回EscapeAnalysis对象，发生逃逸\n     * @return\n     */\n    public EscapeAnalysis getInstance() {\n        return obj == null ? new EscapeAnalysis():obj;\n    }\n\n    /**\n     * 为成员属性赋值，发生逃逸\n     */\n    public void setObj() {\n        this.obj = new EscapeAnalysis();\n    }\n\n    /**\n     * 对象的作用于仅在当前方法中有效，没有发生逃逸\n     */\n    public void useEscapeAnalysis() {\n        EscapeAnalysis e = new EscapeAnalysis();\n    }\n\n    /**\n     * 引用成员变量的值，发生逃逸\n     */\n    public void useEscapeAnalysis2() {\n        EscapeAnalysis e = getInstance();\n        // getInstance().XXX  发生逃逸\n    }\n}\n```\n\n#### 参数设置\n\n在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析\n\n如果使用的是较早的版本，开发人员则可以通过：\n\n- 选项“-xx：+DoEscapeAnalysis\"显式开启逃逸分析\n- 通过选项“-xx：+PrintEscapeAnalysis\"查看逃逸分析的筛选结果\n\n#### 结论\n\n开发中能使用局部变量的，就不要使用在方法外定义。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n- 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n- 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n- 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n### 栈上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n常见的栈上分配的场景\n\n> 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n#### 举例\n\n我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况\n\n```java\n/**\n * 栈上分配\n * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n * @author: 陌溪\n * @create: 2020-07-07-20:23\n */\nclass User {\n    private String name;\n    private String age;\n    private String gender;\n    private String phone;\n}\npublic class StackAllocation {\n    public static void main(String[] args) throws InterruptedException {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 100000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"花费的时间为：\" + (end - start) + \" ms\");\n\n        // 为了方便查看堆内存中对象个数，线程sleep\n        Thread.sleep(10000000);\n    }\n\n    private static void alloc() {\n        // 未发生逃逸\n        User user = new User(); \n    }\n}\n```\n\n设置JVM参数，表示未开启逃逸分析\n\n```\n-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n```\n\n运行结果，同时还触发了GC操作\n\n```\n花费的时间为：664 ms\n```\n\n然后查看内存的情况，发现有大量的User存储在堆中\n\n![image-20200707203038615](images/image-20200707203038615.png)\n\n\n\n我们在开启逃逸分析\n\n```\n-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails\n```\n\n然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作\n\n```\n花费的时间为：5 ms\n```\n\n在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失\n\n![image-20200707203441718](images/image-20200707203441718.png)\n\n\n\n### 同步省略\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n例如下面的代码\n\n```java\npublic void f() {\n    Object hellis = new Object();\n    synchronized(hellis) {\n        System.out.println(hellis);\n    }\n}\n```\n\n代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：\n\n```java\npublic void f() {\n    Object hellis = new Object();\n\tSystem.out.println(hellis);\n}\n```\n\n我们将其转换成字节码\n\n![image-20200707205634266](images/image-20200707205634266.png)\n\n### 分离对象和标量替换\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\n\n相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n```java\npublic static void main(String args[]) {\n    alloc();\n}\nclass Point {\n    private int x;\n    private int y;\n}\nprivate static void alloc() {\n    Point point = new Point(1,2);\n    System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);\n}\n```\n\n以上代码，经过标量替换后，就会变成\n\n```java\nprivate static void alloc() {\n    int x = 1;\n    int y = 2;\n    System.out.println(\"point.x = \" + x + \"; point.y=\" + y);\n}\n```\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。\n标量替换为栈上分配提供了很好的基础。\n\n### 代码优化之标量替换\n\n上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：\n\n```bash\n-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations\n```\n\n这里设置参数如下：\n\n- 参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。\n- 参数-XX:+DoEscapeAnalysis：启用逃逸分析\n- 参数-Xmx10m：指定了堆空间最大为10MB\n- 参数-XX:+PrintGC：将打印Gc日志\n- 参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配\n\n### 逃逸分析的不足\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n\n目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n\n## 小结\n\n年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\n\n老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。\n\n当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。","source":"_posts/java堆.md","raw":"---\ntitle: java堆\ndate: 2023-12-03 21:14:03\ntags: jvm\ncategories: java\n---\n\n# 堆\n\n## 堆的核心概念\n\n堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。\n\n![image-20200706195127740](images/image-20200706195127740.png)\n\n一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\n\nJava堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n\n- 堆内存的大小是可以调节的。\n\n《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n\n所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。\n\n> -Xms10m：最小堆内存\n>\n> -Xmx10m：最大堆内存\n\n下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件\n\n![image-20200706200739392](images/image-20200706200739392.png)\n\n《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）\n\n我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。\n\n- 因为还有一些对象是在栈上分配的\n\n数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\n\n在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n\n- 也就是触发了GC的时候，才会进行回收\n- 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word\n\n堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\n\n![image-20200706201904057](images/image-20200706201904057.png)\n\n### 堆内存细分\n\nJava 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区\n\n- Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区\n- Tenure generation space 养老区 Old/Tenure\n- Permanent Space永久区   Perm\n\nJava 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间\n- Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区\n- Tenure generation space 养老区  Old/Tenure\n- Meta Space  元空间   Meta\n\n约定：新生区 -> 新生代 -> 年轻代   、  养老区 -> 老年区 -> 老年代、 永久区 -> 永久代\n\n![image-20200706203419496](images/image-20200706203419496.png)\n\n堆空间内部结构，JDK1.8之前从永久代  替换成 元空间\n\n![image-20200706203835403](images/image-20200706203835403.png)\n\n\n\n\n\n## 设置堆内存大小与OOM\n\nJava堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项\"-Xmx\"和\"-Xms\"来进行设置。\n\n- “-Xms\"用于表示堆区的起始内存，等价于-xx:InitialHeapSize\n- “-Xmx\"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize\n\n一旦堆区中的内存大小超过“-xmx\"所指定的最大内存时，将会抛出outofMemoryError异常。\n\n通常会将-Xms和-Xmx两个参数配置相同的值，其目的是**为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**。\n\n默认情况下\n\n- 初始内存大小：物理电脑内存大小/64\n\n- 最大内存大小：物理电脑内存大小/4\n\n```java\n/**\n * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小\n *  -X：是jvm运行参数\n *  ms：memory start\n * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小\n *\n * @author: 陌溪\n * @create: 2020-07-06-20:44\n */\npublic class HeapSpaceInitial {\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的堆内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机试图使用的最大堆内存\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n        System.out.println(\"-Xms:\" + initialMemory + \"M\");\n        System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n    }\n}\n```\n\n输出结果\n\n```\n-Xms:245M\n-Xmx:3614M\n```\n\n如何查看堆内存的内存分配情况\n\n```\njps  ->  jstat -gc 进程id\n```\n\n![image-20200706205756045](images/image-20200706205756045.png)\n\n```\n-XX:+PrintGCDetails\n```\n\n![image-20200706205821919](images/image-20200706205821919.png)\n\n### OutOfMemory举例\n\n![image-20200706205947535](images/image-20200706205947535.png)\n\n![image-20200706210000461](images/image-20200706210000461.png)\n\n我们简单的写一个OOM例子\n\n```java\n/**\n * OOM测试\n *\n * @author: 陌溪\n * @create: 2020-07-06-21:11\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        while(true) {\n            list.add(999999999);\n        }\n    }\n}\n\n```\n\n然后设置启动参数\n\n```\n-Xms10m -Xmx:10m\n```\n\n运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM\n\n![image-20200706211652779](images/image-20200706211652779.png)\n\n## 年轻代与老年代\n\n存储在JVM中的Java对象可以被划分为两类：\n- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n  - 生命周期短的，及时回收即可\n- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致\n\nJava堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）\n\n其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）\n\n![image-20200707075847954](images/image-20200707075847954.png)\n\n下面这参数开发中一般不会调：\n\n![image-20200707080154039](images/image-20200707080154039.png)\n\n- Eden：From：to ->  8:1:1\n- 新生代：老年代  - >  1 : 2\n\n配置新生代与老年代在堆结构的占比。\n\n- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n\n- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n> 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优\n\n在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8\n\n几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）\n\n>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n>\n>可以使用选项\"-Xmn\"设置新生代最大内存大小\n>\n>这个参数一般使用默认值就可以了。\n\n![image-20200707084208115](images/image-20200707084208115.png)\n\n## 图解对象分配过程\n\n### 概念\n\n为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\n- new的对象先放伊甸园区。此区有大小限制。\n- 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n- 然后将伊甸园中的剩余对象移动到幸存者0区。\n- 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n- 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n- 啥时候能去养老区呢？可以设置次数。默认是15次。\n- 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理\n- 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。\n\n可以设置参数：-Xx:MaxTenuringThreshold= N进行设置\n\n### 图解过程\n\n我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作\n\n![image-20200707084714886](images/image-20200707084714886.png)\n\n当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。\n\n同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1\n\n![image-20200707085232646](images/image-20200707085232646.png)\n\n我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中\n\n![image-20200707085737207](images/image-20200707085737207.png)\n\n### 思考：幸存区区满了后？\n\n特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作\n\n如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代\n\n> 举例：以当兵为例，正常人的晋升可能是 ：  新兵 -> 班长 -> 排长 -> 连长\n>\n> 但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -> 排长\n\n### 对象分配的特殊情况\n\n![image-20200707091058346](images/image-20200707091058346.png)\n\n### 代码演示对象分配过程\n\n我们不断的创建大对象\n\n```java\n/**\n * 代码演示对象创建过程\n *\n * @author: 陌溪\n * @create: 2020-07-07-9:16\n */\npublic class HeapInstanceTest {\n    byte [] buffer = new byte[new Random().nextInt(1024 * 200)];\n    public static void main(String[] args) throws InterruptedException {\n        ArrayList<HeapInstanceTest> list = new ArrayList<>();\n        while (true) {\n            list.add(new HeapInstanceTest());\n            Thread.sleep(10);\n        }\n    }\n}\n```\n\n然后设置JVM参数\n\n```bash\n-Xms600m -Xmx600m\n```\n\n然后cmd输入下面命令，打开VisualVM图形化界面\n\n```\njvisualvm\n```\n\n然后通过执行上面代码，通过VisualGC进行动态化查看\n\n![垃圾回收](images/垃圾回收.gif)\n\n最终，在老年代和新生代都满了，就出现OOM\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat com.atguigu.java.chapter08.HeapInstanceTest.<init>(HeapInstanceTest.java:13)\n\tat com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)\n```\n\n### 常用的调优工具\n\n- JDK命令行\n- Eclipse：Memory Analyzer Tool\n- Jconsole\n- Visual VM（实时监控  推荐~）\n- Jprofiler（推荐~）\n- Java Flight Recorder（实时监控）\n- GCViewer\n- GCEasy\n\n### 总结\n\n- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to\n- 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集\n- 新生代采用复制算法的目的：是为了减少内碎片\n\n## Minor GC，MajorGC、Full GC\n\n- Minor GC：新生代的GC\n- Major GC：老年代的GC\n- Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集\n\n>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题\n>\n>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上\n\nJVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\n\n部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：\n\n- 新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集\n- 老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。\n  - 目前，只有CMSGC会有单独收集老年代的行为。\n  - 注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。\n- 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。\n  - 目前，只有G1 GC会有这种行为\n\n整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。\n\n### Minor GC\n\n当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）\n\n因为Java对象大多都具备 **朝生夕灭** 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n\nMinor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行\n\n> STW：stop the word\n\n![image-20200707095606813](images/image-20200707095606813.png)\n\n### Major GC\n\n指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了\n\n出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）\n\n- 也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC\n\nMajor GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了\n\n### Full GC\n\n触发Fu11GC执行的情况有如下五种：\n\n- 调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行\n- 老年代空间不足\n- 方法区空间不足\n- 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n- 由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些\n\n\n\n### GC 举例\n\n我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的\n\n```java\n/**\n * GC测试\n *\n * @author: 陌溪\n * @create: 2020-07-07-10:01\n */\npublic class GCTest {\n    public static void main(String[] args) {\n        int i = 0;\n        try {\n            List<String> list = new ArrayList<>();\n            String a = \"mogu blog\";\n            while(true) {\n                list.add(a);\n                a = a + a;\n                i++;\n            }\n        }catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n}\n```\n\n设置JVM启动参数\n\n```bash\n-Xms10m -Xmx10m -XX:+PrintGCDetails\n```\n\n打印出的日志\n\n```\n[GC (Allocation Failure) [PSYoungGen: 2038K->500K(2560K)] 2038K->797K(9728K), 0.3532002 secs] [Times: user=0.01 sys=0.00, real=0.36 secs] \n[GC (Allocation Failure) [PSYoungGen: 2108K->480K(2560K)] 2405K->1565K(9728K), 0.0014069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 2288K->0K(2560K)] [ParOldGen: 6845K->5281K(7168K)] 9133K->5281K(9728K), [Metaspace: 3482K->3482K(1056768K)], 0.0058675 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \n[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 5281K->5281K(9728K), 0.0002857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 5281K->5263K(7168K)] 5281K->5263K(9728K), [Metaspace: 3482K->3482K(1056768K)], 0.0058564 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\n  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)\n  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\n  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\n ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\n  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)\n Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K\n  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K\n  \n  Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat java.util.Arrays.copyOfRange(Arrays.java:3664)\n\tat java.lang.String.<init>(String.java:207)\n\tat java.lang.StringBuilder.toString(StringBuilder.java:407)\n\tat com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)\n```\n\n触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常\n\n## 堆空间分代思想\n\n 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。\n\n>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。\n>老年代：存放新生代中经历多次GC仍然存活的对象。\n\n![image-20200707101511025](images/image-20200707101511025.png)\n\n其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n![image-20200707101543871](images/image-20200707101543871.png)\n\n\n\n## 内存分配策略\n\n如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代\n\n对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置\n\n针对不同年龄段的对象分配原则如下所示：\n\n- 优先分配到Eden\n  - 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢\n- 大对象直接分配到老年代\n  - 尽量避免程序中出现过多的大对象\n- 长期存活的对象分配到老年代\n- 动态对象年龄判断\n  - 如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。\n\n空间分配担保： -Xx:HandlePromotionFailure\n\n- 也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。\n\n## 为对象分配内存：TLAB\n\n### 问题：堆空间都是共享的么？\n\n不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占\n\n### 为什么有TLAB？\n\nTLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区\n\n堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n\n由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\n\n为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n\n### 什么是TLAB\n\n从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。\n\n多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n\n据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\n\n![image-20200707103547712](images/image-20200707103547712.png)\n\n尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。\n\n在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。\n\n默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。\n\n一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。\n\n### TLAB分配过程\n\n对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配\n\n![image-20200707104253530](images/image-20200707104253530.png)\n\n## 小结：堆空间的参数设置\n\n- -XX：+PrintFlagsInitial：查看所有的参数的默认初始值\n- -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）\n- -Xms：初始堆空间内存（默认为物理内存的1/64）\n- -Xmx：最大堆空间内存（默认为物理内存的1/4）\n- -Xmn：设置新生代的大小。（初始值及最大值）\n- -XX:NewRatio：配置新生代与老年代在堆结构的占比\n\n- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例\n- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄\n- -XX：+PrintGCDetails：输出详细的GC处理日志\n  - 打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc\n- -XX:HandlePromotionFalilure：是否设置空间分配担保\n\n\n\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I\n\n- 如果大于，则此次Minor GC是安全的\n- 如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。\n  - 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。\n  - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n  - 如果小于，则改为进行一次FullGC。\n  - 如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。\n\n在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。\n\n## 堆是分配对象的唯一选择么？\n\n### 逃逸分析\n\n在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：\n\n随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\n\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n\n此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\n\n如何将堆上的对象分配到栈，需要使用逃逸分析手段。\n\n这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：\n\n- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\n- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。\n\n#### 逃逸分析举例\n\n没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析\n\n```java\npublic void my_method() {\n    V v = new V();\n    // use v\n    // ....\n    v = null;\n}\n```\n\n针对下面的代码\n\n```java\npublic static StringBuffer createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n```\n\n如果想要StringBuffer sb不发生逃逸，可以这样写\n\n```java\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n```\n\n完整的逃逸分析代码举例\n\n```java\n/**\n * 逃逸分析\n * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n * @author: 陌溪\n * @create: 2020-07-07-20:05\n */\npublic class EscapeAnalysis {\n\n    public EscapeAnalysis obj;\n\n    /**\n     * 方法返回EscapeAnalysis对象，发生逃逸\n     * @return\n     */\n    public EscapeAnalysis getInstance() {\n        return obj == null ? new EscapeAnalysis():obj;\n    }\n\n    /**\n     * 为成员属性赋值，发生逃逸\n     */\n    public void setObj() {\n        this.obj = new EscapeAnalysis();\n    }\n\n    /**\n     * 对象的作用于仅在当前方法中有效，没有发生逃逸\n     */\n    public void useEscapeAnalysis() {\n        EscapeAnalysis e = new EscapeAnalysis();\n    }\n\n    /**\n     * 引用成员变量的值，发生逃逸\n     */\n    public void useEscapeAnalysis2() {\n        EscapeAnalysis e = getInstance();\n        // getInstance().XXX  发生逃逸\n    }\n}\n```\n\n#### 参数设置\n\n在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析\n\n如果使用的是较早的版本，开发人员则可以通过：\n\n- 选项“-xx：+DoEscapeAnalysis\"显式开启逃逸分析\n- 通过选项“-xx：+PrintEscapeAnalysis\"查看逃逸分析的筛选结果\n\n#### 结论\n\n开发中能使用局部变量的，就不要使用在方法外定义。\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n- 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n- 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n- 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n### 栈上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n常见的栈上分配的场景\n\n> 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n#### 举例\n\n我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况\n\n```java\n/**\n * 栈上分配\n * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n * @author: 陌溪\n * @create: 2020-07-07-20:23\n */\nclass User {\n    private String name;\n    private String age;\n    private String gender;\n    private String phone;\n}\npublic class StackAllocation {\n    public static void main(String[] args) throws InterruptedException {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 100000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"花费的时间为：\" + (end - start) + \" ms\");\n\n        // 为了方便查看堆内存中对象个数，线程sleep\n        Thread.sleep(10000000);\n    }\n\n    private static void alloc() {\n        // 未发生逃逸\n        User user = new User(); \n    }\n}\n```\n\n设置JVM参数，表示未开启逃逸分析\n\n```\n-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n```\n\n运行结果，同时还触发了GC操作\n\n```\n花费的时间为：664 ms\n```\n\n然后查看内存的情况，发现有大量的User存储在堆中\n\n![image-20200707203038615](images/image-20200707203038615.png)\n\n\n\n我们在开启逃逸分析\n\n```\n-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails\n```\n\n然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作\n\n```\n花费的时间为：5 ms\n```\n\n在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失\n\n![image-20200707203441718](images/image-20200707203441718.png)\n\n\n\n### 同步省略\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n例如下面的代码\n\n```java\npublic void f() {\n    Object hellis = new Object();\n    synchronized(hellis) {\n        System.out.println(hellis);\n    }\n}\n```\n\n代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：\n\n```java\npublic void f() {\n    Object hellis = new Object();\n\tSystem.out.println(hellis);\n}\n```\n\n我们将其转换成字节码\n\n![image-20200707205634266](images/image-20200707205634266.png)\n\n### 分离对象和标量替换\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\n\n相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\n```java\npublic static void main(String args[]) {\n    alloc();\n}\nclass Point {\n    private int x;\n    private int y;\n}\nprivate static void alloc() {\n    Point point = new Point(1,2);\n    System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);\n}\n```\n\n以上代码，经过标量替换后，就会变成\n\n```java\nprivate static void alloc() {\n    int x = 1;\n    int y = 2;\n    System.out.println(\"point.x = \" + x + \"; point.y=\" + y);\n}\n```\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。\n标量替换为栈上分配提供了很好的基础。\n\n### 代码优化之标量替换\n\n上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：\n\n```bash\n-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations\n```\n\n这里设置参数如下：\n\n- 参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。\n- 参数-XX:+DoEscapeAnalysis：启用逃逸分析\n- 参数-Xmx10m：指定了堆空间最大为10MB\n- 参数-XX:+PrintGC：将打印Gc日志\n- 参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配\n\n### 逃逸分析的不足\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n\n目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n\n## 小结\n\n年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\n\n老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。\n\n当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。","slug":"java堆","published":1,"updated":"2023-12-03T13:14:47.204Z","_id":"clppi7js6000078wfeguhgj36","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><h2 id=\"堆的核心概念\"><a href=\"#堆的核心概念\" class=\"headerlink\" title=\"堆的核心概念\"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>\n<p><img src=\"/images/image-20200706195127740.png\" alt=\"image-20200706195127740\"></p>\n<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\n<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>\n<ul>\n<li>堆内存的大小是可以调节的。</li>\n</ul>\n<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>\n<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>\n<blockquote>\n<p>-Xms10m：最小堆内存</p>\n<p>-Xmx10m：最大堆内存</p>\n</blockquote>\n<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>\n<p><img src=\"/images/image-20200706200739392.png\" alt=\"image-20200706200739392\"></p>\n<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>\n<p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>\n<ul>\n<li>因为还有一些对象是在栈上分配的</li>\n</ul>\n<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>\n<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>\n<ul>\n<li>也就是触发了GC的时候，才会进行回收</li>\n<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>\n</ul>\n<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>\n<p><img src=\"/images/image-20200706201904057.png\" alt=\"image-20200706201904057\"></p>\n<h3 id=\"堆内存细分\"><a href=\"#堆内存细分\" class=\"headerlink\" title=\"堆内存细分\"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>\n<ul>\n<li>Young Generation Space 新生区  Young&#x2F;New   又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区 Old&#x2F;Tenure</li>\n<li>Permanent Space永久区   Perm</li>\n</ul>\n<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>\n<ul>\n<li>Young Generation Space新生区  Young&#x2F;New  又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区  Old&#x2F;Tenure</li>\n<li>Meta Space  元空间   Meta</li>\n</ul>\n<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>\n<p><img src=\"/images/image-20200706203419496.png\" alt=\"image-20200706203419496\"></p>\n<p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p>\n<p><img src=\"/images/image-20200706203835403.png\" alt=\"image-20200706203835403\"></p>\n<h2 id=\"设置堆内存大小与OOM\"><a href=\"#设置堆内存大小与OOM\" class=\"headerlink\" title=\"设置堆内存大小与OOM\"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>\n<ul>\n<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>\n<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>\n</ul>\n<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>\n<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>\n<p>默认情况下</p>\n<ul>\n<li><p>初始内存大小：物理电脑内存大小&#x2F;64</p>\n</li>\n<li><p>最大内存大小：物理电脑内存大小&#x2F;4</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><br><span class=\"hljs-comment\"> *  -X：是jvm运行参数</span><br><span class=\"hljs-comment\"> *  ms：memory start</span><br><span class=\"hljs-comment\"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-06-20:44</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeapSpaceInitial</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 返回Java虚拟机中的堆内存总量</span><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">initialMemory</span> <span class=\"hljs-operator\">=</span> Runtime.getRuntime().totalMemory() / <span class=\"hljs-number\">1024</span> / <span class=\"hljs-number\">1024</span>;<br>        <span class=\"hljs-comment\">// 返回Java虚拟机试图使用的最大堆内存</span><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">maxMemory</span> <span class=\"hljs-operator\">=</span> Runtime.getRuntime().maxMemory() / <span class=\"hljs-number\">1024</span> / <span class=\"hljs-number\">1024</span>;<br>        System.out.println(<span class=\"hljs-string\">&quot;-Xms:&quot;</span> + initialMemory + <span class=\"hljs-string\">&quot;M&quot;</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;-Xmx:&quot;</span> + maxMemory + <span class=\"hljs-string\">&quot;M&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-deletion\">-Xms:245M</span><br><span class=\"hljs-deletion\">-Xmx:3614M</span><br></code></pre></td></tr></table></figure>\n\n<p>如何查看堆内存的内存分配情况</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">jps </span> -&gt;  <span class=\"hljs-keyword\">jstat </span>-gc 进程id<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/images/image-20200706205756045.png\" alt=\"image-20200706205756045\"></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/images/image-20200706205821919.png\" alt=\"image-20200706205821919\"></p>\n<h3 id=\"OutOfMemory举例\"><a href=\"#OutOfMemory举例\" class=\"headerlink\" title=\"OutOfMemory举例\"></a>OutOfMemory举例</h3><p><img src=\"/images/image-20200706205947535.png\" alt=\"image-20200706205947535\"></p>\n<p><img src=\"/images/image-20200706210000461.png\" alt=\"image-20200706210000461\"></p>\n<p>我们简单的写一个OOM例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * OOM测试</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-06-21:11</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OOMTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>            list.add(<span class=\"hljs-number\">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>然后设置启动参数</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-deletion\">-Xms10m -Xmx:10m</span><br></code></pre></td></tr></table></figure>\n\n<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>\n<p><img src=\"/images/image-20200706211652779.png\" alt=\"image-20200706211652779\"></p>\n<h2 id=\"年轻代与老年代\"><a href=\"#年轻代与老年代\" class=\"headerlink\" title=\"年轻代与老年代\"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>\n<ul>\n<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>\n<li>生命周期短的，及时回收即可</li>\n</ul>\n</li>\n<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>\n</ul>\n<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>\n<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>\n<p><img src=\"/images/image-20200707075847954.png\" alt=\"image-20200707075847954\"></p>\n<p>下面这参数开发中一般不会调：</p>\n<p><img src=\"/images/image-20200707080154039.png\" alt=\"image-20200707080154039\"></p>\n<ul>\n<li>Eden：From：to -&gt;  8:1:1</li>\n<li>新生代：老年代  - &gt;  1 : 2</li>\n</ul>\n<p>配置新生代与老年代在堆结构的占比。</p>\n<ul>\n<li><p>默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>\n</li>\n<li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>\n</li>\n</ul>\n<blockquote>\n<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>\n</blockquote>\n<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio&#x3D;8</p>\n<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>\n<blockquote>\n<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>\n<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>\n<p>这个参数一般使用默认值就可以了。</p>\n</blockquote>\n<p><img src=\"/images/image-20200707084208115.png\" alt=\"image-20200707084208115\"></p>\n<h2 id=\"图解对象分配过程\"><a href=\"#图解对象分配过程\" class=\"headerlink\" title=\"图解对象分配过程\"></a>图解对象分配过程</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>\n<ul>\n<li>new的对象先放伊甸园区。此区有大小限制。</li>\n<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>\n<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>\n<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>\n<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>\n<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>\n<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>\n<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>\n</ul>\n<p>可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置</p>\n<h3 id=\"图解过程\"><a href=\"#图解过程\" class=\"headerlink\" title=\"图解过程\"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作</p>\n<p><img src=\"/images/image-20200707084714886.png\" alt=\"image-20200707084714886\"></p>\n<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>\n<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>\n<p><img src=\"/images/image-20200707085232646.png\" alt=\"image-20200707085232646\"></p>\n<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p>\n<p><img src=\"/images/image-20200707085737207.png\" alt=\"image-20200707085737207\"></p>\n<h3 id=\"思考：幸存区区满了后？\"><a href=\"#思考：幸存区区满了后？\" class=\"headerlink\" title=\"思考：幸存区区满了后？\"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>\n<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>\n<blockquote>\n<p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>\n<p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p>\n</blockquote>\n<h3 id=\"对象分配的特殊情况\"><a href=\"#对象分配的特殊情况\" class=\"headerlink\" title=\"对象分配的特殊情况\"></a>对象分配的特殊情况</h3><p><img src=\"/images/image-20200707091058346.png\" alt=\"image-20200707091058346\"></p>\n<h3 id=\"代码演示对象分配过程\"><a href=\"#代码演示对象分配过程\" class=\"headerlink\" title=\"代码演示对象分配过程\"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 代码演示对象创建过程</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-9:16</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeapInstanceTest</span> &#123;<br>    <span class=\"hljs-type\">byte</span> [] buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1024</span> * <span class=\"hljs-number\">200</span>)];<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            list.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HeapInstanceTest</span>());<br>            Thread.sleep(<span class=\"hljs-number\">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后设置JVM参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure>\n\n<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">jvisualvm</span><br></code></pre></td></tr></table></figure>\n\n<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>\n<p><img src=\"/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif\" alt=\"垃圾回收\"></p>\n<p>最终，在老年代和新生代都满了，就出现OOM</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">Exception <span class=\"hljs-keyword\">in</span> thread <span class=\"hljs-string\">&quot;main&quot;</span> java<span class=\"hljs-selector-class\">.lang</span><span class=\"hljs-selector-class\">.OutOfMemoryError</span>: Java heap space<br>\tat com<span class=\"hljs-selector-class\">.atguigu</span><span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.chapter08</span><span class=\"hljs-selector-class\">.HeapInstanceTest</span>.&lt;init&gt;(HeapInstanceTest<span class=\"hljs-selector-class\">.java</span>:<span class=\"hljs-number\">13</span>)<br>\tat com<span class=\"hljs-selector-class\">.atguigu</span><span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.chapter08</span><span class=\"hljs-selector-class\">.HeapInstanceTest</span><span class=\"hljs-selector-class\">.main</span>(HeapInstanceTest<span class=\"hljs-selector-class\">.java</span>:<span class=\"hljs-number\">17</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常用的调优工具\"><a href=\"#常用的调优工具\" class=\"headerlink\" title=\"常用的调优工具\"></a>常用的调优工具</h3><ul>\n<li>JDK命令行</li>\n<li>Eclipse：Memory Analyzer Tool</li>\n<li>Jconsole</li>\n<li>Visual VM（实时监控  推荐~）</li>\n<li>Jprofiler（推荐~）</li>\n<li>Java Flight Recorder（实时监控）</li>\n<li>GCViewer</li>\n<li>GCEasy</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>\n<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>\n<li>新生代采用复制算法的目的：是为了减少内碎片</li>\n</ul>\n<h2 id=\"Minor-GC，MajorGC、Full-GC\"><a href=\"#Minor-GC，MajorGC、Full-GC\" class=\"headerlink\" title=\"Minor GC，MajorGC、Full GC\"></a>Minor GC，MajorGC、Full GC</h2><ul>\n<li>Minor GC：新生代的GC</li>\n<li>Major GC：老年代的GC</li>\n<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>\n</ul>\n<blockquote>\n<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>\n<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>\n</blockquote>\n<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>\n<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>\n<ul>\n<li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li>\n<li>老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。<ul>\n<li>目前，只有CMSGC会有单独收集老年代的行为。</li>\n<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>\n</ul>\n</li>\n<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>\n<li>目前，只有G1 GC会有这种行为</li>\n</ul>\n</li>\n</ul>\n<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>\n<h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>\n<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>\n<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>\n<blockquote>\n<p>STW：stop the word</p>\n</blockquote>\n<p><img src=\"/images/image-20200707095606813.png\" alt=\"image-20200707095606813\"></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>\n<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>\n<ul>\n<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>\n</ul>\n<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p>\n<ul>\n<li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>\n<h3 id=\"GC-举例\"><a href=\"#GC-举例\" class=\"headerlink\" title=\"GC 举例\"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * GC测试</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-10:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GCTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;mogu blog&quot;</span>;<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>设置JVM启动参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure>\n\n<p>打印出的日志</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2038</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">500</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">2038</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">797</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.3532002</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.36</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2108</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">480</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">2405</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">1565</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0014069</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Full</span> <span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Ergonomics</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2288</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">ParOldGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">6845</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">9133</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">Metaspace</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0058675</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0002857</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Full</span> <span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">ParOldGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">Metaspace</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0058564</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-variable\">Heap</span><br> <span class=\"hljs-variable\">PSYoungGen</span>      <span class=\"hljs-variable\">total</span> <span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">60</span><span class=\"hljs-built_in\">K</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">eden</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">2048</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd0f138</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">from</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">to</span>   <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-punctuation\">)</span><br> <span class=\"hljs-variable\">ParOldGen</span>       <span class=\"hljs-variable\">total</span> <span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ff600000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">object</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">73</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ff600000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffb23cf0</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-punctuation\">)</span><br> <span class=\"hljs-variable\">Metaspace</span>       <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">3514</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">capacity</span> <span class=\"hljs-number\">4498</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">committed</span> <span class=\"hljs-number\">4864</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">reserved</span> <span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><br>  <span class=\"hljs-variable\">class</span> <span class=\"hljs-variable\">space</span>    <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">388</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">capacity</span> <span class=\"hljs-number\">390</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">committed</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">reserved</span> <span class=\"hljs-number\">1048576</span><span class=\"hljs-built_in\">K</span><br>  <br>  <span class=\"hljs-variable\">Exception</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-variable\">thread</span> <span class=\"hljs-string\">&quot;main&quot;</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">OutOfMemoryError</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">Java</span> <span class=\"hljs-variable\">heap</span> <span class=\"hljs-variable\">space</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">util</span><span class=\"hljs-operator\">.</span><span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">copyOfRange</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">3664</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">.&lt;</span><span class=\"hljs-variable\">init</span><span class=\"hljs-operator\">&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">207</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">StringBuilder</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">toString</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">StringBuilder</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">407</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">com</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">atguigu</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">chapter08</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">GCTest</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">main</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">GCTest</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">20</span><span class=\"hljs-punctuation\">)</span><br></code></pre></td></tr></table></figure>\n\n<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>\n<h2 id=\"堆空间分代思想\"><a href=\"#堆空间分代思想\" class=\"headerlink\" title=\"堆空间分代思想\"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>\n<blockquote>\n<p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p>\n</blockquote>\n<p><img src=\"/images/image-20200707101511025.png\" alt=\"image-20200707101511025\"></p>\n<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>\n<p><img src=\"/images/image-20200707101543871.png\" alt=\"image-20200707101543871\"></p>\n<h2 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>\n<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>\n<p>针对不同年龄段的对象分配原则如下所示：</p>\n<ul>\n<li>优先分配到Eden<ul>\n<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>\n</ul>\n</li>\n<li>大对象直接分配到老年代<ul>\n<li>尽量避免程序中出现过多的大对象</li>\n</ul>\n</li>\n<li>长期存活的对象分配到老年代</li>\n<li>动态对象年龄判断<ul>\n<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>\n</ul>\n</li>\n</ul>\n<p>空间分配担保： -Xx:HandlePromotionFailure</p>\n<ul>\n<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>\n</ul>\n<h2 id=\"为对象分配内存：TLAB\"><a href=\"#为对象分配内存：TLAB\" class=\"headerlink\" title=\"为对象分配内存：TLAB\"></a>为对象分配内存：TLAB</h2><h3 id=\"问题：堆空间都是共享的么？\"><a href=\"#问题：堆空间都是共享的么？\" class=\"headerlink\" title=\"问题：堆空间都是共享的么？\"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>\n<h3 id=\"为什么有TLAB？\"><a href=\"#为什么有TLAB？\" class=\"headerlink\" title=\"为什么有TLAB？\"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>\n<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>\n<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>\n<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>\n<h3 id=\"什么是TLAB\"><a href=\"#什么是TLAB\" class=\"headerlink\" title=\"什么是TLAB\"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>\n<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>\n<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>\n<p><img src=\"/images/image-20200707103547712.png\" alt=\"image-20200707103547712\"></p>\n<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>\n<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>\n<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>\n<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>\n<h3 id=\"TLAB分配过程\"><a href=\"#TLAB分配过程\" class=\"headerlink\" title=\"TLAB分配过程\"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>\n<p><img src=\"/images/image-20200707104253530.png\" alt=\"image-20200707104253530\"></p>\n<h2 id=\"小结：堆空间的参数设置\"><a href=\"#小结：堆空间的参数设置\" class=\"headerlink\" title=\"小结：堆空间的参数设置\"></a>小结：堆空间的参数设置</h2><ul>\n<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>\n</li>\n<li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>\n</li>\n<li><p>-Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）</p>\n</li>\n<li><p>-Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）</p>\n</li>\n<li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p>\n</li>\n<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>\n</li>\n<li><p>-XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>\n</li>\n<li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>\n<ul>\n<li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li>\n</ul>\n</li>\n<li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>\n</li>\n</ul>\n<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>\n<ul>\n<li>如果大于，则此次Minor GC是安全的</li>\n<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>\n<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>\n<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>\n<li>如果小于，则改为进行一次FullGC。</li>\n<li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Ful1 Gc。</li>\n</ul>\n</li>\n</ul>\n<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>\n<h2 id=\"堆是分配对象的唯一选择么？\"><a href=\"#堆是分配对象的唯一选择么？\" class=\"headerlink\" title=\"堆是分配对象的唯一选择么？\"></a>堆是分配对象的唯一选择么？</h2><h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>\n<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>\n<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>\n<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>\n<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>\n<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>\n<ul>\n<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>\n</ul>\n<h4 id=\"逃逸分析举例\"><a href=\"#逃逸分析举例\" class=\"headerlink\" title=\"逃逸分析举例\"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">my_method</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">V</span> <span class=\"hljs-variable\">v</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">V</span>();<br>    <span class=\"hljs-comment\">// use v</span><br>    <span class=\"hljs-comment\">// ....</span><br>    v = <span class=\"hljs-literal\">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>针对下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> StringBuffer <span class=\"hljs-title function_\">createStringBuffer</span><span class=\"hljs-params\">(String s1, String s2)</span> &#123;<br>    <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class=\"hljs-keyword\">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">createStringBuffer</span><span class=\"hljs-params\">(String s1, String s2)</span> &#123;<br>    <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class=\"hljs-keyword\">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>完整的逃逸分析代码举例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 逃逸分析</span><br><span class=\"hljs-comment\"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-20:05</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EscapeAnalysis</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> EscapeAnalysis obj;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> EscapeAnalysis <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> obj == <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>():obj;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 为成员属性赋值，发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setObj</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useEscapeAnalysis</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">EscapeAnalysis</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 引用成员变量的值，发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useEscapeAnalysis2</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">EscapeAnalysis</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> getInstance();<br>        <span class=\"hljs-comment\">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>\n<p>如果使用的是较早的版本，开发人员则可以通过：</p>\n<ul>\n<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>\n<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<ul>\n<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>\n<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>\n<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>\n</ul>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>\n<p>常见的栈上分配的场景</p>\n<blockquote>\n<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>\n</blockquote>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 栈上分配</span><br><span class=\"hljs-comment\"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-20:23</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> String name;<br>    <span class=\"hljs-keyword\">private</span> String age;<br>    <span class=\"hljs-keyword\">private</span> String gender;<br>    <span class=\"hljs-keyword\">private</span> String phone;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackAllocation</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br>        System.out.println(<span class=\"hljs-string\">&quot;花费的时间为：&quot;</span> + (end - start) + <span class=\"hljs-string\">&quot; ms&quot;</span>);<br><br>        <span class=\"hljs-comment\">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class=\"hljs-number\">10000000</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-comment\">// 未发生逃逸</span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>设置JVM参数，表示未开启逃逸分析</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-title class_\">Xmx1</span>G -<span class=\"hljs-title class_\">Xms1</span>G -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:-DoEscapeAnalysis</span> -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p>运行结果，同时还触发了GC操作</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">花费的时间为：664 ms<br></code></pre></td></tr></table></figure>\n\n<p>然后查看内存的情况，发现有大量的User存储在堆中</p>\n<p><img src=\"/images/image-20200707203038615.png\" alt=\"image-20200707203038615\"></p>\n<p>我们在开启逃逸分析</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-title class_\">Xmx1</span>G -<span class=\"hljs-title class_\">Xms1</span>G -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+DoEscapeAnalysis</span> -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">花费的时间为：5 ms<br></code></pre></td></tr></table></figure>\n\n<p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p>\n<p><img src=\"/images/image-20200707203441718.png\" alt=\"image-20200707203441718\"></p>\n<h3 id=\"同步省略\"><a href=\"#同步省略\" class=\"headerlink\" title=\"同步省略\"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>\n<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>\n<p>例如下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">hellis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>();<br>    <span class=\"hljs-keyword\">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">hellis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>();<br>\tSystem.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们将其转换成字节码</p>\n<p><img src=\"/images/image-20200707205634266.png\" alt=\"image-20200707205634266\"></p>\n<h3 id=\"分离对象和标量替换\"><a href=\"#分离对象和标量替换\" class=\"headerlink\" title=\"分离对象和标量替换\"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>\n<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y;<br>&#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">point</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;point.x&quot;</span> + point.x + <span class=\"hljs-string\">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上代码，经过标量替换后，就会变成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>    System.out.println(<span class=\"hljs-string\">&quot;point.x = &quot;</span> + x + <span class=\"hljs-string\">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>\n<h3 id=\"代码优化之标量替换\"><a href=\"#代码优化之标量替换\" class=\"headerlink\" title=\"代码优化之标量替换\"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure>\n\n<p>这里设置参数如下：</p>\n<ul>\n<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>\n<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>\n<li>参数-Xmx10m：指定了堆空间最大为10MB</li>\n<li>参数-XX:+PrintGC：将打印Gc日志</li>\n<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>\n</ul>\n<h3 id=\"逃逸分析的不足\"><a href=\"#逃逸分析的不足\" class=\"headerlink\" title=\"逃逸分析的不足\"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>\n<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>\n<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>\n<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><h2 id=\"堆的核心概念\"><a href=\"#堆的核心概念\" class=\"headerlink\" title=\"堆的核心概念\"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>\n<p><img src=\"/images/image-20200706195127740.png\" alt=\"image-20200706195127740\"></p>\n<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\n<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>\n<ul>\n<li>堆内存的大小是可以调节的。</li>\n</ul>\n<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>\n<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>\n<blockquote>\n<p>-Xms10m：最小堆内存</p>\n<p>-Xmx10m：最大堆内存</p>\n</blockquote>\n<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>\n<p><img src=\"/images/image-20200706200739392.png\" alt=\"image-20200706200739392\"></p>\n<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>\n<p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>\n<ul>\n<li>因为还有一些对象是在栈上分配的</li>\n</ul>\n<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>\n<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>\n<ul>\n<li>也就是触发了GC的时候，才会进行回收</li>\n<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>\n</ul>\n<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>\n<p><img src=\"/images/image-20200706201904057.png\" alt=\"image-20200706201904057\"></p>\n<h3 id=\"堆内存细分\"><a href=\"#堆内存细分\" class=\"headerlink\" title=\"堆内存细分\"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>\n<ul>\n<li>Young Generation Space 新生区  Young&#x2F;New   又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区 Old&#x2F;Tenure</li>\n<li>Permanent Space永久区   Perm</li>\n</ul>\n<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>\n<ul>\n<li>Young Generation Space新生区  Young&#x2F;New  又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区  Old&#x2F;Tenure</li>\n<li>Meta Space  元空间   Meta</li>\n</ul>\n<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>\n<p><img src=\"/images/image-20200706203419496.png\" alt=\"image-20200706203419496\"></p>\n<p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p>\n<p><img src=\"/images/image-20200706203835403.png\" alt=\"image-20200706203835403\"></p>\n<h2 id=\"设置堆内存大小与OOM\"><a href=\"#设置堆内存大小与OOM\" class=\"headerlink\" title=\"设置堆内存大小与OOM\"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>\n<ul>\n<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>\n<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>\n</ul>\n<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>\n<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>\n<p>默认情况下</p>\n<ul>\n<li><p>初始内存大小：物理电脑内存大小&#x2F;64</p>\n</li>\n<li><p>最大内存大小：物理电脑内存大小&#x2F;4</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><br><span class=\"hljs-comment\"> *  -X：是jvm运行参数</span><br><span class=\"hljs-comment\"> *  ms：memory start</span><br><span class=\"hljs-comment\"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-06-20:44</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeapSpaceInitial</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 返回Java虚拟机中的堆内存总量</span><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">initialMemory</span> <span class=\"hljs-operator\">=</span> Runtime.getRuntime().totalMemory() / <span class=\"hljs-number\">1024</span> / <span class=\"hljs-number\">1024</span>;<br>        <span class=\"hljs-comment\">// 返回Java虚拟机试图使用的最大堆内存</span><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">maxMemory</span> <span class=\"hljs-operator\">=</span> Runtime.getRuntime().maxMemory() / <span class=\"hljs-number\">1024</span> / <span class=\"hljs-number\">1024</span>;<br>        System.out.println(<span class=\"hljs-string\">&quot;-Xms:&quot;</span> + initialMemory + <span class=\"hljs-string\">&quot;M&quot;</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;-Xmx:&quot;</span> + maxMemory + <span class=\"hljs-string\">&quot;M&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-deletion\">-Xms:245M</span><br><span class=\"hljs-deletion\">-Xmx:3614M</span><br></code></pre></td></tr></table></figure>\n\n<p>如何查看堆内存的内存分配情况</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">jps </span> -&gt;  <span class=\"hljs-keyword\">jstat </span>-gc 进程id<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/images/image-20200706205756045.png\" alt=\"image-20200706205756045\"></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/images/image-20200706205821919.png\" alt=\"image-20200706205821919\"></p>\n<h3 id=\"OutOfMemory举例\"><a href=\"#OutOfMemory举例\" class=\"headerlink\" title=\"OutOfMemory举例\"></a>OutOfMemory举例</h3><p><img src=\"/images/image-20200706205947535.png\" alt=\"image-20200706205947535\"></p>\n<p><img src=\"/images/image-20200706210000461.png\" alt=\"image-20200706210000461\"></p>\n<p>我们简单的写一个OOM例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * OOM测试</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-06-21:11</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OOMTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>            list.add(<span class=\"hljs-number\">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>然后设置启动参数</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-deletion\">-Xms10m -Xmx:10m</span><br></code></pre></td></tr></table></figure>\n\n<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>\n<p><img src=\"/images/image-20200706211652779.png\" alt=\"image-20200706211652779\"></p>\n<h2 id=\"年轻代与老年代\"><a href=\"#年轻代与老年代\" class=\"headerlink\" title=\"年轻代与老年代\"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>\n<ul>\n<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>\n<li>生命周期短的，及时回收即可</li>\n</ul>\n</li>\n<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>\n</ul>\n<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>\n<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>\n<p><img src=\"/images/image-20200707075847954.png\" alt=\"image-20200707075847954\"></p>\n<p>下面这参数开发中一般不会调：</p>\n<p><img src=\"/images/image-20200707080154039.png\" alt=\"image-20200707080154039\"></p>\n<ul>\n<li>Eden：From：to -&gt;  8:1:1</li>\n<li>新生代：老年代  - &gt;  1 : 2</li>\n</ul>\n<p>配置新生代与老年代在堆结构的占比。</p>\n<ul>\n<li><p>默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>\n</li>\n<li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>\n</li>\n</ul>\n<blockquote>\n<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>\n</blockquote>\n<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio&#x3D;8</p>\n<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>\n<blockquote>\n<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>\n<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>\n<p>这个参数一般使用默认值就可以了。</p>\n</blockquote>\n<p><img src=\"/images/image-20200707084208115.png\" alt=\"image-20200707084208115\"></p>\n<h2 id=\"图解对象分配过程\"><a href=\"#图解对象分配过程\" class=\"headerlink\" title=\"图解对象分配过程\"></a>图解对象分配过程</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>\n<ul>\n<li>new的对象先放伊甸园区。此区有大小限制。</li>\n<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>\n<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>\n<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>\n<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>\n<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>\n<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>\n<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>\n</ul>\n<p>可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置</p>\n<h3 id=\"图解过程\"><a href=\"#图解过程\" class=\"headerlink\" title=\"图解过程\"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作</p>\n<p><img src=\"/images/image-20200707084714886.png\" alt=\"image-20200707084714886\"></p>\n<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>\n<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>\n<p><img src=\"/images/image-20200707085232646.png\" alt=\"image-20200707085232646\"></p>\n<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p>\n<p><img src=\"/images/image-20200707085737207.png\" alt=\"image-20200707085737207\"></p>\n<h3 id=\"思考：幸存区区满了后？\"><a href=\"#思考：幸存区区满了后？\" class=\"headerlink\" title=\"思考：幸存区区满了后？\"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>\n<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>\n<blockquote>\n<p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>\n<p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p>\n</blockquote>\n<h3 id=\"对象分配的特殊情况\"><a href=\"#对象分配的特殊情况\" class=\"headerlink\" title=\"对象分配的特殊情况\"></a>对象分配的特殊情况</h3><p><img src=\"/images/image-20200707091058346.png\" alt=\"image-20200707091058346\"></p>\n<h3 id=\"代码演示对象分配过程\"><a href=\"#代码演示对象分配过程\" class=\"headerlink\" title=\"代码演示对象分配过程\"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 代码演示对象创建过程</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-9:16</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeapInstanceTest</span> &#123;<br>    <span class=\"hljs-type\">byte</span> [] buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1024</span> * <span class=\"hljs-number\">200</span>)];<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            list.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HeapInstanceTest</span>());<br>            Thread.sleep(<span class=\"hljs-number\">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后设置JVM参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure>\n\n<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">jvisualvm</span><br></code></pre></td></tr></table></figure>\n\n<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>\n<p><img src=\"/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif\" alt=\"垃圾回收\"></p>\n<p>最终，在老年代和新生代都满了，就出现OOM</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">Exception <span class=\"hljs-keyword\">in</span> thread <span class=\"hljs-string\">&quot;main&quot;</span> java<span class=\"hljs-selector-class\">.lang</span><span class=\"hljs-selector-class\">.OutOfMemoryError</span>: Java heap space<br>\tat com<span class=\"hljs-selector-class\">.atguigu</span><span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.chapter08</span><span class=\"hljs-selector-class\">.HeapInstanceTest</span>.&lt;init&gt;(HeapInstanceTest<span class=\"hljs-selector-class\">.java</span>:<span class=\"hljs-number\">13</span>)<br>\tat com<span class=\"hljs-selector-class\">.atguigu</span><span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.chapter08</span><span class=\"hljs-selector-class\">.HeapInstanceTest</span><span class=\"hljs-selector-class\">.main</span>(HeapInstanceTest<span class=\"hljs-selector-class\">.java</span>:<span class=\"hljs-number\">17</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常用的调优工具\"><a href=\"#常用的调优工具\" class=\"headerlink\" title=\"常用的调优工具\"></a>常用的调优工具</h3><ul>\n<li>JDK命令行</li>\n<li>Eclipse：Memory Analyzer Tool</li>\n<li>Jconsole</li>\n<li>Visual VM（实时监控  推荐~）</li>\n<li>Jprofiler（推荐~）</li>\n<li>Java Flight Recorder（实时监控）</li>\n<li>GCViewer</li>\n<li>GCEasy</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>\n<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>\n<li>新生代采用复制算法的目的：是为了减少内碎片</li>\n</ul>\n<h2 id=\"Minor-GC，MajorGC、Full-GC\"><a href=\"#Minor-GC，MajorGC、Full-GC\" class=\"headerlink\" title=\"Minor GC，MajorGC、Full GC\"></a>Minor GC，MajorGC、Full GC</h2><ul>\n<li>Minor GC：新生代的GC</li>\n<li>Major GC：老年代的GC</li>\n<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>\n</ul>\n<blockquote>\n<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>\n<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>\n</blockquote>\n<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>\n<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>\n<ul>\n<li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li>\n<li>老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。<ul>\n<li>目前，只有CMSGC会有单独收集老年代的行为。</li>\n<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>\n</ul>\n</li>\n<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>\n<li>目前，只有G1 GC会有这种行为</li>\n</ul>\n</li>\n</ul>\n<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>\n<h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>\n<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>\n<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>\n<blockquote>\n<p>STW：stop the word</p>\n</blockquote>\n<p><img src=\"/images/image-20200707095606813.png\" alt=\"image-20200707095606813\"></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>\n<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>\n<ul>\n<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>\n</ul>\n<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p>\n<ul>\n<li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>\n<h3 id=\"GC-举例\"><a href=\"#GC-举例\" class=\"headerlink\" title=\"GC 举例\"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * GC测试</span><br><span class=\"hljs-comment\"> *</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-10:01</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GCTest</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;mogu blog&quot;</span>;<br>            <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>设置JVM启动参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure>\n\n<p>打印出的日志</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2038</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">500</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">2038</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">797</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.3532002</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.36</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2108</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">480</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">2405</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">1565</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0014069</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Full</span> <span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Ergonomics</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">2288</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">ParOldGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">6845</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">9133</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">Metaspace</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0058675</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0002857</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Full</span> <span class=\"hljs-variable\">GC</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">Allocation</span> <span class=\"hljs-built_in\">Failure</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">PSYoungGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">0</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">ParOldGen</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-number\">5281</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">9728</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-variable\">Metaspace</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">-&gt;</span><span class=\"hljs-number\">3482</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0.0058564</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">Times</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">user</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span> <span class=\"hljs-variable\">sys</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.00</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">real</span><span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0.01</span> <span class=\"hljs-variable\">secs</span><span class=\"hljs-punctuation\">]</span> <br><span class=\"hljs-variable\">Heap</span><br> <span class=\"hljs-variable\">PSYoungGen</span>      <span class=\"hljs-variable\">total</span> <span class=\"hljs-number\">2560</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">60</span><span class=\"hljs-built_in\">K</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">eden</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">2048</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd0f138</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">from</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff00000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">to</span>   <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000fff80000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x0000000100000000</span><span class=\"hljs-punctuation\">)</span><br> <span class=\"hljs-variable\">ParOldGen</span>       <span class=\"hljs-variable\">total</span> <span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">5263</span><span class=\"hljs-built_in\">K</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ff600000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-punctuation\">)</span><br>  <span class=\"hljs-variable\">object</span> <span class=\"hljs-variable\">space</span> <span class=\"hljs-number\">7168</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">73</span><span class=\"hljs-operator\">%</span> <span class=\"hljs-variable\">used</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ff600000</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffb23cf0</span><span class=\"hljs-operator\">,</span><span class=\"hljs-number\">0</span><span class=\"hljs-variable\">x00000000ffd00000</span><span class=\"hljs-punctuation\">)</span><br> <span class=\"hljs-variable\">Metaspace</span>       <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">3514</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">capacity</span> <span class=\"hljs-number\">4498</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">committed</span> <span class=\"hljs-number\">4864</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">reserved</span> <span class=\"hljs-number\">1056768</span><span class=\"hljs-built_in\">K</span><br>  <span class=\"hljs-variable\">class</span> <span class=\"hljs-variable\">space</span>    <span class=\"hljs-variable\">used</span> <span class=\"hljs-number\">388</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">capacity</span> <span class=\"hljs-number\">390</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">committed</span> <span class=\"hljs-number\">512</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">reserved</span> <span class=\"hljs-number\">1048576</span><span class=\"hljs-built_in\">K</span><br>  <br>  <span class=\"hljs-variable\">Exception</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-variable\">thread</span> <span class=\"hljs-string\">&quot;main&quot;</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">OutOfMemoryError</span><span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">Java</span> <span class=\"hljs-variable\">heap</span> <span class=\"hljs-variable\">space</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">util</span><span class=\"hljs-operator\">.</span><span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">copyOfRange</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">3664</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">.&lt;</span><span class=\"hljs-variable\">init</span><span class=\"hljs-operator\">&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">207</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">lang</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">StringBuilder</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">toString</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">StringBuilder</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">407</span><span class=\"hljs-punctuation\">)</span><br>\t<span class=\"hljs-variable\">at</span> <span class=\"hljs-variable\">com</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">atguigu</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">chapter08</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">GCTest</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">main</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">GCTest</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">20</span><span class=\"hljs-punctuation\">)</span><br></code></pre></td></tr></table></figure>\n\n<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>\n<h2 id=\"堆空间分代思想\"><a href=\"#堆空间分代思想\" class=\"headerlink\" title=\"堆空间分代思想\"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>\n<blockquote>\n<p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p>\n</blockquote>\n<p><img src=\"/images/image-20200707101511025.png\" alt=\"image-20200707101511025\"></p>\n<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>\n<p><img src=\"/images/image-20200707101543871.png\" alt=\"image-20200707101543871\"></p>\n<h2 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>\n<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>\n<p>针对不同年龄段的对象分配原则如下所示：</p>\n<ul>\n<li>优先分配到Eden<ul>\n<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>\n</ul>\n</li>\n<li>大对象直接分配到老年代<ul>\n<li>尽量避免程序中出现过多的大对象</li>\n</ul>\n</li>\n<li>长期存活的对象分配到老年代</li>\n<li>动态对象年龄判断<ul>\n<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>\n</ul>\n</li>\n</ul>\n<p>空间分配担保： -Xx:HandlePromotionFailure</p>\n<ul>\n<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>\n</ul>\n<h2 id=\"为对象分配内存：TLAB\"><a href=\"#为对象分配内存：TLAB\" class=\"headerlink\" title=\"为对象分配内存：TLAB\"></a>为对象分配内存：TLAB</h2><h3 id=\"问题：堆空间都是共享的么？\"><a href=\"#问题：堆空间都是共享的么？\" class=\"headerlink\" title=\"问题：堆空间都是共享的么？\"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>\n<h3 id=\"为什么有TLAB？\"><a href=\"#为什么有TLAB？\" class=\"headerlink\" title=\"为什么有TLAB？\"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>\n<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>\n<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>\n<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>\n<h3 id=\"什么是TLAB\"><a href=\"#什么是TLAB\" class=\"headerlink\" title=\"什么是TLAB\"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>\n<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>\n<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>\n<p><img src=\"/images/image-20200707103547712.png\" alt=\"image-20200707103547712\"></p>\n<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>\n<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>\n<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>\n<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>\n<h3 id=\"TLAB分配过程\"><a href=\"#TLAB分配过程\" class=\"headerlink\" title=\"TLAB分配过程\"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>\n<p><img src=\"/images/image-20200707104253530.png\" alt=\"image-20200707104253530\"></p>\n<h2 id=\"小结：堆空间的参数设置\"><a href=\"#小结：堆空间的参数设置\" class=\"headerlink\" title=\"小结：堆空间的参数设置\"></a>小结：堆空间的参数设置</h2><ul>\n<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>\n</li>\n<li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>\n</li>\n<li><p>-Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）</p>\n</li>\n<li><p>-Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）</p>\n</li>\n<li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p>\n</li>\n<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>\n</li>\n<li><p>-XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>\n</li>\n<li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>\n<ul>\n<li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li>\n</ul>\n</li>\n<li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>\n</li>\n</ul>\n<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>\n<ul>\n<li>如果大于，则此次Minor GC是安全的</li>\n<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>\n<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>\n<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>\n<li>如果小于，则改为进行一次FullGC。</li>\n<li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Ful1 Gc。</li>\n</ul>\n</li>\n</ul>\n<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>\n<h2 id=\"堆是分配对象的唯一选择么？\"><a href=\"#堆是分配对象的唯一选择么？\" class=\"headerlink\" title=\"堆是分配对象的唯一选择么？\"></a>堆是分配对象的唯一选择么？</h2><h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>\n<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>\n<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>\n<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>\n<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>\n<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>\n<ul>\n<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>\n</ul>\n<h4 id=\"逃逸分析举例\"><a href=\"#逃逸分析举例\" class=\"headerlink\" title=\"逃逸分析举例\"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">my_method</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">V</span> <span class=\"hljs-variable\">v</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">V</span>();<br>    <span class=\"hljs-comment\">// use v</span><br>    <span class=\"hljs-comment\">// ....</span><br>    v = <span class=\"hljs-literal\">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>针对下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> StringBuffer <span class=\"hljs-title function_\">createStringBuffer</span><span class=\"hljs-params\">(String s1, String s2)</span> &#123;<br>    <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class=\"hljs-keyword\">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">createStringBuffer</span><span class=\"hljs-params\">(String s1, String s2)</span> &#123;<br>    <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class=\"hljs-keyword\">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>完整的逃逸分析代码举例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 逃逸分析</span><br><span class=\"hljs-comment\"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-20:05</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EscapeAnalysis</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> EscapeAnalysis obj;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> EscapeAnalysis <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> obj == <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>():obj;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 为成员属性赋值，发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setObj</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useEscapeAnalysis</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">EscapeAnalysis</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 引用成员变量的值，发生逃逸</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useEscapeAnalysis2</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">EscapeAnalysis</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> getInstance();<br>        <span class=\"hljs-comment\">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>\n<p>如果使用的是较早的版本，开发人员则可以通过：</p>\n<ul>\n<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>\n<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<ul>\n<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>\n<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>\n<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>\n</ul>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>\n<p>常见的栈上分配的场景</p>\n<blockquote>\n<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>\n</blockquote>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 栈上分配</span><br><span class=\"hljs-comment\"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span>: 陌溪</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@create</span>: 2020-07-07-20:23</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> String name;<br>    <span class=\"hljs-keyword\">private</span> String age;<br>    <span class=\"hljs-keyword\">private</span> String gender;<br>    <span class=\"hljs-keyword\">private</span> String phone;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackAllocation</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br>        System.out.println(<span class=\"hljs-string\">&quot;花费的时间为：&quot;</span> + (end - start) + <span class=\"hljs-string\">&quot; ms&quot;</span>);<br><br>        <span class=\"hljs-comment\">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class=\"hljs-number\">10000000</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-comment\">// 未发生逃逸</span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>设置JVM参数，表示未开启逃逸分析</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-title class_\">Xmx1</span>G -<span class=\"hljs-title class_\">Xms1</span>G -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:-DoEscapeAnalysis</span> -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p>运行结果，同时还触发了GC操作</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">花费的时间为：664 ms<br></code></pre></td></tr></table></figure>\n\n<p>然后查看内存的情况，发现有大量的User存储在堆中</p>\n<p><img src=\"/images/image-20200707203038615.png\" alt=\"image-20200707203038615\"></p>\n<p>我们在开启逃逸分析</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">-<span class=\"hljs-title class_\">Xmx1</span>G -<span class=\"hljs-title class_\">Xms1</span>G -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+DoEscapeAnalysis</span> -<span class=\"hljs-variable constant_\">XX</span><span class=\"hljs-symbol\">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure>\n\n<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">花费的时间为：5 ms<br></code></pre></td></tr></table></figure>\n\n<p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p>\n<p><img src=\"/images/image-20200707203441718.png\" alt=\"image-20200707203441718\"></p>\n<h3 id=\"同步省略\"><a href=\"#同步省略\" class=\"headerlink\" title=\"同步省略\"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>\n<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>\n<p>例如下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">hellis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>();<br>    <span class=\"hljs-keyword\">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">hellis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>();<br>\tSystem.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们将其转换成字节码</p>\n<p><img src=\"/images/image-20200707205634266.png\" alt=\"image-20200707205634266\"></p>\n<h3 id=\"分离对象和标量替换\"><a href=\"#分离对象和标量替换\" class=\"headerlink\" title=\"分离对象和标量替换\"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>\n<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y;<br>&#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">point</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>    System.out.println(<span class=\"hljs-string\">&quot;point.x&quot;</span> + point.x + <span class=\"hljs-string\">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上代码，经过标量替换后，就会变成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">alloc</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>    System.out.println(<span class=\"hljs-string\">&quot;point.x = &quot;</span> + x + <span class=\"hljs-string\">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>\n<h3 id=\"代码优化之标量替换\"><a href=\"#代码优化之标量替换\" class=\"headerlink\" title=\"代码优化之标量替换\"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure>\n\n<p>这里设置参数如下：</p>\n<ul>\n<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>\n<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>\n<li>参数-Xmx10m：指定了堆空间最大为10MB</li>\n<li>参数-XX:+PrintGC：将打印Gc日志</li>\n<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>\n</ul>\n<h3 id=\"逃逸分析的不足\"><a href=\"#逃逸分析的不足\" class=\"headerlink\" title=\"逃逸分析的不足\"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>\n<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>\n<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>\n<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clpphmypn0000ekwf46zva9pa","category_id":"clpphmypu0001ekwf8gqb444a","_id":"clpphmypw0004ekwfaahhc1kv"},{"post_id":"clpphw94t0000xcwfa31scsxq","category_id":"clpphmypu0001ekwf8gqb444a","_id":"clpphw94y0002xcwf8x2zeas8"},{"post_id":"clppi1yvu0003xcwfej0tcc1h","category_id":"clpphmypu0001ekwf8gqb444a","_id":"clppi31gr0005xcwf9nyn455m"},{"post_id":"clppi7js6000078wfeguhgj36","category_id":"clpphmypu0001ekwf8gqb444a","_id":"clppi8h6u000278wffu1kbjlk"}],"PostTag":[{"post_id":"clpphmypn0000ekwf46zva9pa","tag_id":"clpphmypv0002ekwfg4y8510n","_id":"clpphmypw0003ekwf0w9m9o69"},{"post_id":"clpphw94t0000xcwfa31scsxq","tag_id":"clpphmypv0002ekwfg4y8510n","_id":"clpphw94x0001xcwfh7v30zm0"},{"post_id":"clppi1yvu0003xcwfej0tcc1h","tag_id":"clpphmypv0002ekwfg4y8510n","_id":"clppi31gq0004xcwffy2zhgyg"},{"post_id":"clppi7js6000078wfeguhgj36","tag_id":"clpphmypv0002ekwfg4y8510n","_id":"clppi8h6t000178wf5s9h2dof"}],"Tag":[{"name":"jvm","_id":"clpphmypv0002ekwfg4y8510n"}]}}